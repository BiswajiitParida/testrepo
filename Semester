Semester 
Interview 
Industry 
-------------------------------------------
Project :

Notepad Application using swing
▪ Calculator Project using AWT
▪ Address Book using JDBC
▪ Puzzle Game using Swing
▪ Snake game using Swing
▪ Chatting Application using Networking
▪ Paint Application using Applet
▪ Library information System using Swing

-------------------------------------------
Full Stack Developer 
-----------------------------------
	
	Knowlege to become Full Stack Developer 
----------------------------------------
	Front-End / UI 		:	HTML/CSS/Bootstrap/Javascript/Jquery/Ajax/JSON/Angular 
	Language 			:	Java (Core Java /  Advanced Java)   
	Back-End / Database :	Oracle (SQL and PL/SQL) 



No relation b/w java and Javascript

Web devt 
----------------
	Php 
	asp 
	jsp / java 
	ruby 
	python 
	
Download Software 
-----------------------





Application Area of Java 
-------------------------
	
	SE (Standard Edition) 	/	Core Java 
	-----------------------------------------
			By using SE , we can develop Desktop/standalone application.
			
			Desktop application : Application runs in a single machine and need to install. 
			Example:  Editor / Media player / Browser / Client-side page / IDE ...etc 
			IDE (Integrated Devt. Env.) like Ecplise/Netbeans/Visual Studio/Vs-Code/IJ..etc 

▪ Notepad Application using swing
▪ Calculator Project using AWT
▪ Address Book using JDBC
▪ Puzzle Game using Swing
▪ Snake game using Swing
▪ Chatting Application using Networking
▪ Paint Application using Applet
▪ Library information System using Swing


	EE  (Enterprise Edition) / Adv. Java 
	-----------------------------------------
			By using EE , we can develop web application i.e. website. 
			Normal website

	ME (Micro Edition) / Android 
	------------------------------
		By using ME , we can develop mobile application.


	Framework 
	--------------
		By using Framework , we can develop enterprise/E-Commerce application.
		E-Commerce website 

		Spring 
		Hibernate 


---------------------------------------------------
UI Technologies 
---------------------
	HTML/CSS/Javascript/Bootstrap/JQuery/Ajax/JSON/Typescript/ECMAScript/Angular 

	5 months 
	Fee - 5000/- 



Java language used to create appliation software , not suitable for system software. 

System software 
-------------------
	O/S 
	Kernel 
	Device Driver 
	Protocol 
	Database 
	..............................

	Core language like C/C++/...etc 

	Microsoft / Oracle / Google 

Application software
------------------------
	Game 
	Desktop 
	Website 
	E-Commerce 
	Mobile 
	Emb. apps 

	Language :	Java/.Net/PHP/Python/...etc 

	TCS/Infy/CTS/Cap/Ama/Flip/Microsoft/Oracle ...etc 



Java History 
-------------------------





About Java 
---------------------
	
	Java is developed by James Gosling. 
	Java was the product of Sun Micro System upto 2010. 
	Now Java is the product of ORACLE compay. 
	Latest version of Java is JDK - 15. JDK stands for Java Devt. Kit 

	Version History 
	-----------------
		JDK 1.0
		JDK 1.1
		JDK 1.2
		JDK 1.3
		JDK 1.4
		JDK 1.5
		JDK 1.6
		JDK 1.7

		JDK 8.0
		JDK 9.0
		JDK 10.0
		JDK 11.0
		JDK 12.0
		JDK 13.0
		JDK 14.0
		JDK 15.0 released on 15 September 2020.


	Java is an object oriented programming language. 

	object oriented programming Language:	If a Programming language support OOPs (Object Oriented Programming structure )concept then it is known OOPL. 

	C doesnot support any concept of Object Oriented standard, so we can say 

	Object oriented concepts 
	-----------------------------------
		Class 
		Object 

		Inheritance 
		Polymorphism 
		Abstraction 
		Encapsulation 

		Association 
		Aggregation 
		Composition 
		Coupling 


What are the concepts Java Language doesnot support comapre with C/C++ (C/C++ vs Java)
---------------------------------------------------------------------------------------
	
	1.	Pointer 	:	Java doesnot support the concept of pointer due to security issue, in java, "reference" is the replacement of pointer. 

	2.	Garbage Value :	No garbage concepts available in Java 
			int a ;  // in C/C++ , u  will get a random value

	3.	Memory de-allocation : After use the memory , you can relese/de-allocates in C/C++ but in java , it automatically released.

		To free the memory 
		--------------------------------------
		C 		:		free() function 
		C++ 	:		destructor 


	4.	structure and union :	class/interface can replace it. 

	5.	System software :	C/C++ very flexible to deveop system software, but Java is not flexible. 

	6.	Header file 


Features of Java 
-------------------------------
	
	1.	Platform Independent 
	2.	Open Source 
	3.	Architecture Neutral 
	4.	Secure 
	5.	Robust 
	6.	Strongly Handle the exception 
	7.	Object Oriented 
	8.	Jshell 
	9.	var 
	10.	Portable 
	11.	for-each concept 
	12.	High performance  / switch enhancement 
	13.	distributed 
	15.	multithreded 
	16.	text-block 
	17.	Automatic Memory Management 
	18.	Garbage Collection 
	19.	Lambda/Regular Expression 
	20. single File application devt. 


Platform Independent 
-------------------------
	Here Platform means windows/linux/mac....etc.

	C/C++ completly Platform dependent. 

	 Platform dependent :	If an application only can be executed in a specific env. 
	 Platform independent :	If an application can be executed in different O/S. 

	 Slogan of Java is WORA (Write Once Runs Anywhere).


	 Java is completly Platform independent. 

	 Extension of java file/program .java 

	 After compiler compile the .java file it will create .class file. 

	 .java file contains source code. 
	 .class file contains byte code. 

	 source code cannot be executed. 
	 byte code can be executed. 

	 Name of the java compiler is javac





	 Platform Independent 
-------------------------
	Here Platform means windows/linux/mac....etc.

	C/C++ completly Platform dependent. 

	 Platform dependent :	If an application only can be executed in a specific env. 
	 Platform independent :	If an application can be executed in different O/S. 

	 Slogan of Java is WORA (Write Once Runs Anywhere).


	 Java is completly Platform independent. 

	 Extension of java file/program .java 

	 After compiler compile the .java file it will create .class file. 

	 .java file contains source code. 
	 .class file contains byte code. 

	 source code cannot be executed. 
	 byte code can be executed. 

	 Name of the java compiler is javac 
	 

Procedure to develop a java application
-----------------------------------------------
	
	1.	Create a file and save with .java extension  (First.java)
	2.	Write the following program 

			class Test {

				public static void main(String[] args) {
					
					System.out.println("Hello welcome to Java world ..:)");
				}
			}

	3.	Save the file (ctrl+s) 

	4.	Now open the command prompt 

	5.	Compile the java program 

				D:\5-6>javac   Filename.java 
				D:\5-6>javac   First.java


	6.	Execute  the java program 

				D:\5-6>java 	classname
				D:\5-6>java 	Test
			


D:\5-6>javac  -version   // To check  the version of the compiler 
javac 14.0.1

D:\5-6>java  -version 	// To check  the version of the runtime enviorment 
java version "14.0.1" 2020-04-14
Java(TM) SE Runtime Environment (build 14.0.1+7)
Java HotSpot(TM) 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing)




To compile and execute the java program , it is required to set the path.

How to set the path 
--------------------
	We can set the path by two ways 

		1.	Temporary period 

			D:\5-6>set path=;C:\Program Files\Java\jdk1.6.0_45\bin;

			D:\5-6>javac  -version
			javac 1.6.0_45	

		2.	Permanently 


My Computer 
	|
	|	
	|->	Right Click 
			|	
			|->	Properties
					|	
					|->	Advanced System Settings 
							|
							|->	Enviorment Variables
										|
										|->	System Variable 
												|
												|-> Selec the variable 
														"path"
														  |
														  |->Edit 
														  	  |
														  	  |-> New 
														  	  	   |
														  	  	   |-> Paste the path 
														  	  	   		C:\Program Files\Java\jdk-14.0.1\bin

														  	  	   			|
														  	  	   			|-> Ok (3)







Open Source 
-------------------------
	Source code is not restricted within Oracle company  or Sun micro system.
	It is freely available for any user. 

	Location of entire source code after JDK 8 : C:\Program Files\Java\jdk-14.0.1\lib\src.zip
	Location of entire source code on before JDK 8 : C:\Program Files\Java\jdk-1.8\src.zip

	Source code can be customized in the local machine only. 


Java comments 
---------------------
	
	Java support three types of comment

		1.	Single line comment 

				//  Java code  / Message 

		2.	Multi-line comments 

				/* 
					Java codes  / Messages 
				*/

		3.	Documentation comments 

				 /**
						Java codes / Messages
				 */	

JShell 
----------------------------------------
	It is a JDK tool , newly introduced in Java.

	It is used to test the function without writing java program. 

D:\5-6>jshell
|  Welcome to JShell -- Version 14.0.1
|  For an introduction type: /help intro

jshell> "hello"
$1 ==> "hello"

jshell> System.out.println("Hi")
Hi

jshell> 10+20
$3 ==> 30

jshell> int a=100
a ==> 100

jshell> int b=200
b ==> 200

jshell> a+b
$6 ==> 300

jshell> Math.sqrt(9)
$7 ==> 3.0

jshell> "Hello Hi"
$8 ==> "Hello Hi"

jshell> String s = "Hello" + "Java"
s ==> "HelloJava"

jshell> s
s ==> "HelloJava"

jshell> /exit
|  Goodbye


Architecture Neutral 
-----------------------------
	
	From Java point of view, memory allocation and de-allocation is same for all enviorment, which indicates Java  is purely Architecture Neutral PL.

	C/C++ is not Architecture neutral. 

	C/C++ 
	------------

		int  a[100000];


		Note:	It allocates 4 bytes in Linux(GCC compiler) and 2 bytes in windows(TCC compiler) . 

	Java 
	---------------
		int  a[100000];

		It reserves same memory in all O/S.








var concept 
----------------------------
	It is newly introduced in Java. 
	It is the replacement of datatype. 


By using datatype
---------------------------------
	class Test {

	public static void main(String[] args) {
		
		int a = 10;
		String s = "Hello";
		float f = 5.4f;
		double d = 5.4;
		long x = 10l;

		System.out.println(a);
		System.out.println(s);
		System.out.println(f);
		System.out.println(d);
		System.out.println(x);

	}
}
By using var 
---------------------------------
class Test {

	public static void main(String[] args) {
		
		var a = 10;
		var s = "Hello";
		var f = 5.4f;
		var d = 5.4;
		var x = 10l;

		System.out.println(a);
		System.out.println(s);
		System.out.println(f);
		System.out.println(d);
		System.out.println(x);
	}
}


De-Compiler :	It is a software , which is used to trace the .class file. 		
				.class file contains byte code. 
				To understand the byte code, De-Compiler can be used. 


Object Oriented 
--------------------------
	Java is an object oriented  programming language. 
	Object Oriented is nothing but a standard, it contains some rules and regulation.
	Rules and regulations are known as OOPs concpts. 
	If a PL, follow Object Oriented standard then it is known as Object Oriented programming Language, by using that language application devt. is more flexible. 

	Example of OO PL 
	------------------------
	C++/Java/PHP/Python/C# 

	C doesnot support any concept of Object Oriented standard, so we can say C is not a Object Oriented PL. 

	Object oriented concepts 
	-----------------------------------
		Class 
		Object 

		Inheritance 
		Polymorphism 
		Abstraction 
		Encapsulation 

		Association 
		Aggregation 
		Composition 
		Coupling 

Portable 
------------------------
	If an application can be executed in different O/S and different devices i.e. Portable. 

Single File Application Devt. 
------------------------------------
	
	Generally we are compiling the .java file then it will create a .class file means two file created 

			1.	.java 
			2.	.class 

	Java newly introduced a concept Single File Application Devt, through which a .java file can be executed directly  without creating a .class file explictly. 

	Here Compiler compile the .java file internally. 


class Test {

	public static void main(String[] args) {
		
		System.out.println("Hello Welcome ");


	}
}

D:\5-6>java     Test.java
Hello Welcome


Example:	
class Test {

	public static void main(String[] args) {
		
		System.out.println("Java");
	}
}

class Demo {

	public static void main(String[] args) {
		
		System.out.println(".Net");
	}
}

Note:	D:\5-6>java     Test.java
		Java 

		The above command will execute  the class which designed very first in that file.
		To execute any other class, you need to compile then execute the class file. 


Automatic Memory Management 
---------------------------------------------
	
	In Java , memory de-allocation is not the responsiblity of a  Java programmer. 

	In Java, there is no concept of release or free the memory. 

	Java support automatic memory Management to released the unused memory. 

	After use the memory , you can relese/de-allocates in C/C++ but in java , it automatically released.

	To free the memory 
	--------------------------------------

		C 		:		free() function 
		C++ 	:		destructor 

	Note: 	JVM (Java Virtual Machine) is responsible  to release the un-allocated memory.








Automatic Memory Management 
---------------------------------------------
	
	In Java , memory de-allocation is not the responsiblity of a  Java programmer. 

	In Java, there is no concept of release or free the memory. 

	Java support automatic memory Management to released the unused memory. 

	After use the memory , you can relese/de-allocates in C/C++ but in java , it automatically released.

	To free the memory 
	--------------------------------------

		C 		:		free() function 
		C++ 	:		destructor 

	Note: 	JVM (Java Virtual Machine) is responsible  to release the un-allocated memory. 


Robust 
---------------------
	Robust means Strong. 
	Java is a Robust language due to following three reasons 

		1.	Automatic memory Management
		2.	Garbage Collection 
		3.	Strongly Handle the Exception

Garbage Collection  
----------------------
	Java doesnot support any garbage value. 
	JVM is responsible to collect garbage by calling gc() method which is present in System class.

	int x ; 	//	It allocates 4 bytes from RAM 

Secure 
--------------------
	Java is secure  due to following two reasons 

		1.	Lack of pointer concept 
		2.	Running within a VM (Virtual Machine)

---------------------------------------------------------------------

					Introduction 
-----------------------------------------------------------------

// First.java (File name)
public class First {

	public static void main(String[] args) {
		

		System.out.println("Hello");
	}
}

Access Specifier in Java 
===========================================
	Access specifiers are known as Access modifiers. 
	Following are the Access modifiers available in Java 

		1.	public 
		2.	protected 
		3.	default 
		4.	private 

		5.	volatile
		6.	transient
		7.	strictfp
		8.	static 
		9.	abstract
		10. final 
		11.	synchronized
		12.	native

		A-Z 		=	Alphabets 
		A E I O U 	=	Vowels

		Note:	Out of 12 modifiers , public/protected/default/private are known as access specifiers. 

		Job of Access Specifier
		----------------------------
			It is used to set the scope/boundary of 

				->	variable/object 
				->	function 
				->	constructor 
				->	class 


		Types of access specifiers
		---------------------------------
			1.	public 			
			2.	protected 
			3.	default 
			4.	private 

Scope table 
---------------------


Example: Access Specifier 
-----------------------------
class Test  {

	public static int a  = 10;
	protected static int b  = 20;
	static int c  = 30;
	private static int d  = 40;

	public static void main(String[] args) {
		
		System.out.println(Test.a);
		System.out.println(Test.b);
		System.out.println(Test.c);
		System.out.println(Test.d);
	}
}

class Demo {

	//	Here d cannot be called 
	public static void main(String[] args) {
		
		System.out.println(Test.a);
		System.out.println(Test.b);
		System.out.println(Test.c);
		//System.out.println(Test.d); // Error : d has private access in Test
	}
}

Note: 	When a class is declared as public, then file name and class name must be same. 
		
		private and protected access specifiers are not allowed for the top-level class. 

		For nested class, all the access specifiers are allowed. 

		Class within a class is known as nested class. 

public class First {

	public class A {}
	protected class B {}
	class C {}
	private class D {}
}

class Demo {}

//	protected class Teacher { }	//	 error: modifier protected not allowed here

// private class Student {} //  error: modifier private not allowed here



Write all the keywords 
----------------------------------


Why outer class cannot be declared as private and  protected ? 
----------------------------------------------------------------------






Write all the keywords 
----------------------------------


Why outer class cannot be declared as private ?
----------------------------------------------------------------------

	As private member only can be accessed within same class, so ther is no meaning to declare a class  as private. 


Why outer class cannot be declared as protected?
-----------------------------------------------------------------------------
	
	If the member is protected then it can be accessed  within the package but outside of the package required Inheritance. 


	class having two scope 

		1.	Within the same package :		Here class must be default 
		2.	Outside of the package :		Here class must be public 


class 
-------------

	It is a container. 
	
	It contains four types of member 
	
		1.	variable /	data member
		2.	block 
		3.	function / method member 
		4.	constructoor 

	class is a logical container , it doesnot allocates memory. 

	Object is the physical existence of class. 

	Syntax to create object in Java 
	-----------------------------------

		ClassName objectName = new ClassName() ; 

		Student  s = new Student ();

	class Student {

		int roll;
		String name; 

		Student raja = new Student();
		Student rani = new Student();
	}

	javac  	:	Compile 
	java 	:	Run 
	jshell 	:	Test 
	javap 	:	Trace 

	Note:	javap is a jdk tool , which is responsible to display the members of a .class file 

class Test {

	public int a = 10;
	protected int b = 20;
	int c = 30;
	private int d = 40;

	public static void main(String[] args) {
		
		System.out.println("Example of Javap");
	}
}

	D:\5-6>javac   First.java

D:\5-6>javap  -public    Test 		//	Display all the public members 
Compiled from "First.java"
class Test {
  public int a;
  public static void main(java.lang.String[]);
}

D:\5-6>javap  -protected    Test  //	Display all the public and protected members 
Compiled from "First.java"
class Test {
  public int a;
  protected int b;
  public static void main(java.lang.String[]);
}

D:\5-6>javap      Test  		//	Display all the public,protected and default members 
Compiled from "First.java"
class Test {
  public int a;
  protected int b;
  int c;
  Test();
  public static void main(java.lang.String[]);
}

D:\5-6>javap  -private     Test 		//	Display all the public,protected,default and private members 
Compiled from "First.java"
class Test {
  public int a;
  protected int b;
  int c;
  private int d;
  Test();
  public static void main(java.lang.String[]);
}

Identifier 
-----------------------------
	
	class name / variable name / function name / constructor name / package name / constant name / object name etc are known as Identifier. 

	To identify  a member , we have to give a name i.e. known as Identifier. 

	Rules of Identifier
	-------------------------

		->	Digits are allowed but not at beginning. 
					
					int x1;
					int 1x;	//	error 

		->	keywords are not allowed 

		->	Space is not allowed 

		->	Symbols are not allowed except Dollar ($) and Underscore(_). 


	Naming Conventions according to Java
	--------------------------------------

		class name 		:	First letter of each must be capital.
							Example:	String 
										BufferedReader 
										InputStreamReader 

		Function name 	:	Except 1st word, first letter of each must be capital.
							Example:	toCharArray();

		Package name 	:	Each letter must be lowercase 
							java 
							lang 
							util 
							io 

		constant name 	:	Each letter must be capital. 
							SIZE 
							BOLD 


About main() method 
----------------------------
	public static void main(String[] args)

	->	main is  purely user-defined method. 

	->	Proptotype/Signature of main() method is pre-defined i.e. public static void main(String[] args)

	
	->	Existence of main() method doesnot check by compiler . 

	->	main() method is the entry point of execution. 

	->	main() method is called by JVM in Java. 

	JVM 
	----------------
		It stands for Java Virtual Machine. 

		JVM is a software which is in-built  within each and every O/S. 

		JVM is purely developed in C language. 

		As it is developed in C, it is Platform dependent. 

		JVM is Platform dependent , but it makes Java Platform independent. 

		JVM for the windows and Linux is different but jobs are same 

		Following are the tasks of JVM 

		1.	Execute the byte code  / .class file 
		2.	Call the main () method 
		3.	Automatic Memory Management 
		4.	Collect Garbage value 
		5.	File Management
		6.	Device driver Management 
		7.	Socket Management
		8.	Thread Management 
		9.	I/O devices Management
		10.	Process Management






Why main() must be public ? 
-------------------------------------
	
	If main() method is not public , then it is a run-time error 

	D:\5-6>javac First.java

	D:\5-6>java First
	Error: Main method not found in class First, please define the main method as:
	   public static void main(String[] args)
	or a JavaFX application class must extend javafx.application.Application

	JVM calls the main() method from O/S , as main() method resides in a different package, so it must be public.


Why main() must be static ? 
-------------------------------------
	
	static  and non-static decides how to access/call a member (variable/function).

	Java support three different ways to call a static member 

		1.	directly possible within same class 
		2.	by class name 
		3.	by object name 

	Java support following technique to call a non-static member 

		1.	by object name 
		
Example:	Calling procedure (static and non-static member)
--------------------------------------------------------------- 
class Test  {

	static int x = 10;		//	static member 
	int y=20;				//	non-static member 

	public static  void main(String[] args) {
	
		Test t1 = new Test ();

		System.out.println(x);		//	directly 
		System.out.println(Test.x);	//	class name 
		System.out.println(t1.x);	//	object name 

		System.out.println(t1.y);	//	object name 
	}
}
class Demo  {

	public static  void main(String[] args) {
	
		Test t1 = new Test ();

		//System.out.println(x);		//	directly  calling is an error 
		System.out.println(Test.x);	//	class name 
		System.out.println(t1.x);	//	object name 

		System.out.println(t1.y);	//	object name 

	}
}

Why main() method  must be static in Java ?
---------------------------------------------------------------------
	
	JVM calls the main() method by class name , according to calling procedure , if a member is called by class name , it must be static , so main() method must be static in java. 

class Test  {

	static void show() {

		System.out.println("Hello");
	}
}
class Demo  {

	public static  void main(String[] args) {
	
		Test.show();
	}
}

Example:	Multiple main() method can be declared within a single class , JVM only call that main() method which accept array of String as an arguments 
---------------------------------------------------------------------------

class Test {

	public static void main(int x) {
	
		System.out.println("Java");	
	}
	public static void main(String[] args) {
		
		System.out.println("Hello");
		main(123);
		main("abc");
	}

	public static void main(String s) {
		
		System.out.println("Hi");
	}
}

void 
-------------------
public class First {

	public static int main(String[] args) {
		
		return 0 ; 

	}
}

 Error: Main method must return a value of type void in class First, please

 Note:	If a function doesnot return any value , return type must be void. 

 		Here main() method doesnot return any value to JVM , so return type must be void. 

Commandline Arguments 
-------------------------------
	
	The argument which is accepted by main() method is known as Commandline argument. 

	In java, main() method always accept array of String as an argument. 


	String 		s = "Hello";				//	only String 
	String  	s[] = {"Java","UI","Oracle"}; // Array of String 

	public static void main(String[] args) {
		
	}

	Array declaration 
	------------------------
		String[] 	args
		String 		args[] 
		String 		[]args


	Commandline argument is used as an input technique in Java.

	How to pass value in Commandline 
	--------------------------------------
		
public class First {

	public static void main(String[] x) {
		
		System.out.println("Hello");
		System.out.println(x.length);
	}
}


// length variable is used to findout the size of array in Java 

D:\5-6>javac First.java

D:\5-6>java First
Hello
0

D:\5-6>java First 11
Hello
1

D:\5-6>java First 11 22
Hello
2

D:\5-6>java First 11 22 100
Hello
3





Example: display 
-------------------------
public class First {

	public static void main(String[] args) {
		
		if(args.length > 0) {
			System.out.println("All the commandline argumnets are ");
			for(int i=0 ; i < args.length ; i++) {

				System.out.println(args[i]);
			}
		}
		else
			System.out.println("No argumnets entered from commandline");
	}
}
D:\5-6>javac   First.java

D:\5-6>java First
No argumnets entered from commandline

D:\5-6>java First 10 abc Hello 20
All the commandline argumnets are
10
abc
Hello
20
------------------------------------------------

Example: Check the commandline argument is even or odd 
public class First {

	public static void main(String[] args) {
		
		if(args.length > 0) {
			
			for(int i=0 ; i < args.length ; i++) {

				int num = Integer.parseInt(args[i]);
				if(num % 2 == 0 )
					System.out.println(num +" is Even");
				else
					System.out.println(num +" is Odd");
			}
		}
		else
			System.out.println("No argumnets entered from commandline");
	}
}

// parseInt() :	It is used to convert a String to int. 
//parseDouble() :	It is used to convert a String to double 


System.out.println();
----------------------------
	System 		:	It is a class present in java.lang package . 
	
	out 		:	It is a static object of java.io.PrintStream class
					This object present is System class. 
	
	println()	:	It is a non-static method of PrintStream class. 
					It is responsible to display something in console. 



Mapping Program of System.out.println();
--------------------------------------------
class Test  {

	void show() {

		System.out.println("Java is Simple ...:) ");
	}
}
class Demo {

	static Test t = new Test ();
}
class MainClass {

	public static void main(String[] args) {
		
		Demo.t.show();

	}
}

D:\5-6>javap java.io.PrintStream

D:\5-6>javap java.lang.System


print() vs println () 
----------------------------
	
	print() 	:	It is used to print the text.
	println() 	:	It is used to print the text and put a new line at the end. 


	
public class First {

	public static void main(String[] args) {
		
		System.out.println ("1");
		System.out.print ("2");
		System.out.print ("3");
		System.out.print ("4");
		System.out.println ("5");
		System.out.println ("6");
		System.out.print ("7");
		System.out.println ("8");
	}
}

D:\5-6>javac   First.java

D:\5-6>java First
1
2345
6
78

About Plus (+)
==================
	
	In Java, you can plus (+) symbol to perform two different task 

		1.	Arithmetic operation / Addition 
		2.	Concat in case of String 



public class First {

	public static void main(String[] args) {
	
		int x = 10;
		int y=20;
		System.out.println(x+y);

		System.out.println("10"+"20");	

		System.out.println("10"+20);

		System.out.println(Integer.parseInt("10")+20);

		System.out.println(2+3+"10"+2+3+(2+3)+2*3);
	}
}

D:\5-6>java First.java
30
1020
1020
30
5102356


System.out vs System.err
--------------------------
	
	public class First {

	public static void main(String[] args) {
	
		System.out.println("Hello");
		System.err.println("Hi");
	}
}


If the output is generated by System.out can be redirected to a file. 
If the output is generated by System.err cannot be redirected to a file. 

D:\5-6>java First
Hello
Hi

D:\5-6>java First >  a.txt  // Here a.txt will be created automatically and output will be stored
Hi

D:\5-6>java First >>  a.txt  // append data into the existing file 
Hi



class Test {

	public static void main(String[] args) {
		
		byte x = 10;
		Byte y = 20;
		System.out.println(x+"\t"+y);

		System.out.println(Byte.MAX_VALUE);
		System.out.println(Byte.MIN_VALUE);
		System.out.println(Byte.SIZE);
		System.out.println("10"+x);
		System.out.println(Byte.parseByte("10")+x);
		System.out.println(x+50);
	}
}





Datatypes in Java 
-------------------------
	Types of Datatype 
	----------
		1.	Primitive 		:	Size is fixed 
		2.	Non-Primitive  	:	Size is defined by programmer 


Java support 8 Primitive Datatypes 
						
						size  			default_value 
						---------------------------------

	1.	byte  			8bits 				0	
	2.	char 			16bits 				/u0
	3.	short 			16bits 				0
	4.	int 			32bits 				0
	5.	long 			64bits 				0L
	6.	float 			32bits 				0.0f 
	7.	double 			64bits 				0.0
	8.	boolean 		1bit 				false 


Wrapper class 
---------------------------------
	For each Primitive Datatype , Java support a pre-defined class i.e. known as Wrapper class. 

	All the wrapper classes are present in java.lang package. 

Use of Datatype
---------------------
	It allocates a sequence set of bytes from RAM. 
	It indicates the type of data. 

Use of wrapper class 
----------------------------
	To manipulate Datatype according to requirement. 
	Type Conversion 

		
						size  			default_value 			Wrapper-class 
						-------------------------------------------------------

	1.	byte  			8bits 				0					Byte 
	2.	char 			16bits 				/u0 				Character 
	3.	short 			16bits 				0					Short 
	4.	int 			32bits 				0 					Integer 
	5.	long 			64bits 				0L 					Long 
	6.	float 			32bits 				0.0f  				Float 
	7.	double 			64bits 				0.0 				Double 
	8.	boolean 		1bit 				false  				Boolean 

Note:	Scripting language doesnot support datatype. 


byte and Byte 
---------------------------------------------
	5 		binary is 	101 
	101 	value is 	5 

class Test {

	public static void main(String[] args) {
		
		byte x = 10;
		Byte y = 20;
		System.out.println(x+"\t"+y);

		System.out.println(Byte.MAX_VALUE);
		System.out.println(Byte.MIN_VALUE);
		System.out.println(Byte.SIZE);
		System.out.println("10"+x);
		System.out.println(Byte.parseByte("10")+x);
		System.out.println(x+50);
	}
}






Datatypes in Java 
-------------------------
	Types of Datatype 
	----------
		1.	Primitive 		:	Size is fixed 
		2.	Non-Primitive  	:	Size is defined by programmer 


Java support 8 Primitive Datatypes 
						
						size  			default_value 
						---------------------------------

	1.	byte  			8bits 				0	
	2.	char 			16bits 				/u0
	3.	short 			16bits 				0
	4.	int 			32bits 				0
	5.	long 			64bits 				0L
	6.	float 			32bits 				0.0f 
	7.	double 			64bits 				0.0
	8.	boolean 		1bit 				false 


Wrapper class 
---------------------------------
	For each Primitive Datatype , Java support a pre-defined class i.e. known as Wrapper class. 

	All the wrapper classes are present in java.lang package. 

Use of Datatype
---------------------
	It allocates a sequence set of bytes from RAM. 
	It indicates the type of data. 

Use of wrapper class 
----------------------------
	To manipulate Datatype according to requirement. 
	Type Conversion 

		
						size  			default_value 			Wrapper-class 
						-------------------------------------------------------

	1.	byte  			8bits 				0					Byte 
	2.	char 			16bits 				/u0 				Character 
	3.	short 			16bits 				0					Short 
	4.	int 			32bits 				0 					Integer 
	5.	long 			64bits 				0L 					Long 
	6.	float 			32bits 				0.0f  				Float 
	7.	double 			64bits 				0.0 				Double 
	8.	boolean 		1bit 				false  				Boolean 

Note:	Scripting language doesnot support datatype. 


byte and Byte 
---------------------------------------------
	5 		binary is 	101 
	101 	value is 	5 


class Test {

	public static void main(String[] args) {
		
		byte x = 10;
		Byte y = 20;
		System.out.println(x+"\t"+y);

		System.out.println(Byte.MAX_VALUE);
		System.out.println(Byte.MIN_VALUE);
		System.out.println(Byte.SIZE);
		System.out.println("10"+x);
		System.out.println(Byte.parseByte("10")+x);
		System.out.println(x+50);
		System.out.println(Byte.toString(x)+50);
	}
}
D:\5-6>java Test.java
10      20
127
-128
8
1010
20
60

Note:
		
		MAX_VALUE and MIN_VALUE  return the range of datatype. 

		SIZE return the size of datatype

		parseByte()	:	It converts String to byte 


D:\5-6>javap java.lang.Character

D:\5-6>javap java.lang.Integer

lang is the default package in java. 


short and int 
--------------------------------
	class Test {

	public static void main(String[] args) {
		
		short x = 10;
		
		System.out.println(x);

		System.out.println(Short.MAX_VALUE);
		System.out.println(Short.MIN_VALUE);
		System.out.println(Short.SIZE);
		System.out.println("10"+x);
		System.out.println(Short.parseShort("10")+x);
		System.out.println(x+50);
		System.out.println(Short.toString(x)+50);

		System.out.println(Integer.MAX_VALUE);
		System.out.println(Integer.MIN_VALUE);
		System.out.println(Integer.SIZE);
		System.out.println("10"+x);
		System.out.println(Integer.parseInt("10")+x);
		System.out.println(x+50);
		System.out.println(Integer.toString(x)+50);

		System.out.println(Integer.toBinaryString(5)); // Decimal to Binary
		System.out.println(Integer.toBinaryString(-5)); // Decimal to Binary
		System.out.println(Integer.toOctalString(10));	// Decinal to octal 
		System.out.println(Integer.toHexString(10));	// Decimal to Hexa-decimal

		System.out.println(010);
		System.out.println(0x10);
		System.out.println(010+20);
		System.out.println(0x10+20);
		System.out.println(0b10+10);
	}
}

constant 
-----------------
	
	5		-	int constant 
	'5'		-	char 
	"5"		-	String 
	05		-	octa 
	0x5		-	Hexa-decimal
	5.0		-	double 
	5.0d 	-	double 
	5.0f 	-	float 
	5L		-	long 
	0b10	-	binary 

long 
----------------
class Test {

	public static void main(String[] args) {
		

		long x=10;
		System.out.println(Long.MAX_VALUE);
		System.out.println(Long.MIN_VALUE);
		System.out.println(Long.SIZE);
		System.out.println("10"+x);
		System.out.println(Long.parseLong("10")+x);
		System.out.println(x+50);
		System.out.println(Long.toString(x)+50);
		System.out.println(Integer.MAX_VALUE);
		long a = 9223372036854775807L;
		System.out.println(a);

	}
}

float and double 
------------------------
	class Test {

	public static void main(String[] args) {

		System.out.println(Float.MAX_VALUE);
		System.out.println(Float.MIN_VALUE);
		System.out.println(Float.SIZE);


		System.out.println(Double.MAX_VALUE);
		System.out.println(Double.MIN_VALUE);
		System.out.println(Double.SIZE);
	}
}

boolean 
----------------
	It holds true and false. 

	class Test {

	public static void main(String[] args) {

		boolean x = true;

		System.out.println(x);

		boolean a = 1;
		
	}
}

char 
----------------
	char support UNICODE in Java.
	UNICODE :	Universal Code 

	C/C++ support ASCII standard. 

	UNICODE is the combination of ASCII and local language Characters.





Datatypes in Java 
-------------------------
	Types of Datatype 
	----------
		1.	Primitive 		:	Size is fixed 
		2.	Non-Primitive  	:	Size is defined by programmer 


Java support 8 Primitive Datatypes 
						
						size  			default_value 
						---------------------------------

	1.	byte  			8bits 				0	
	2.	char 			16bits 				/u0
	3.	short 			16bits 				0
	4.	int 			32bits 				0
	5.	long 			64bits 				0L
	6.	float 			32bits 				0.0f 
	7.	double 			64bits 				0.0
	8.	boolean 		1bit 				false 


Wrapper class 
---------------------------------
	For each Primitive Datatype , Java support a pre-defined class i.e. known as Wrapper class. 

	All the wrapper classes are present in java.lang package. 

Use of Datatype
---------------------
	It allocates a sequence set of bytes from RAM. 
	It indicates the type of data. 

Use of wrapper class 
----------------------------
	To manipulate Datatype according to requirement. 
	Type Conversion 

		
						size  			default_value 			Wrapper-class 
						-------------------------------------------------------

	1.	byte  			8bits 				0					Byte 
	2.	char 			16bits 				/u0 				Character 
	3.	short 			16bits 				0					Short 
	4.	int 			32bits 				0 					Integer 
	5.	long 			64bits 				0L 					Long 
	6.	float 			32bits 				0.0f  				Float 
	7.	double 			64bits 				0.0 				Double 
	8.	boolean 		1bit 				false  				Boolean 

Note:	Scripting language doesnot support datatype. 


byte and Byte 
---------------------------------------------
	5 		binary is 	101 
	101 	value is 	5 


class Test {

	public static void main(String[] args) {
		
		byte x = 10;
		Byte y = 20;
		System.out.println(x+"\t"+y);

		System.out.println(Byte.MAX_VALUE);
		System.out.println(Byte.MIN_VALUE);
		System.out.println(Byte.SIZE);
		System.out.println("10"+x);
		System.out.println(Byte.parseByte("10")+x);
		System.out.println(x+50);
		System.out.println(Byte.toString(x)+50);
	}
}
D:\5-6>java Test.java
10      20
127
-128
8
1010
20
60

Note:
		
		MAX_VALUE and MIN_VALUE  return the range of datatype. 

		SIZE return the size of datatype

		parseByte()	:	It converts String to byte 


D:\5-6>javap java.lang.Character

D:\5-6>javap java.lang.Integer

lang is the default package in java. 


short and int 
--------------------------------
	class Test {

	public static void main(String[] args) {
		
		short x = 10;
		
		System.out.println(x);

		System.out.println(Short.MAX_VALUE);
		System.out.println(Short.MIN_VALUE);
		System.out.println(Short.SIZE);
		System.out.println("10"+x);
		System.out.println(Short.parseShort("10")+x);
		System.out.println(x+50);
		System.out.println(Short.toString(x)+50);

		System.out.println(Integer.MAX_VALUE);
		System.out.println(Integer.MIN_VALUE);
		System.out.println(Integer.SIZE);
		System.out.println("10"+x);
		System.out.println(Integer.parseInt("10")+x);
		System.out.println(x+50);
		System.out.println(Integer.toString(x)+50);

		System.out.println(Integer.toBinaryString(5)); // Decimal to Binary
		System.out.println(Integer.toBinaryString(-5)); // Decimal to Binary
		System.out.println(Integer.toOctalString(10));	// Decinal to octal 
		System.out.println(Integer.toHexString(10));	// Decimal to Hexa-decimal

		System.out.println(010);
		System.out.println(0x10);
		System.out.println(010+20);
		System.out.println(0x10+20);
		System.out.println(0b10+10);
	}
}

constant 
-----------------
	
	5		-	int constant 
	'5'		-	char 
	"5"		-	String 
	05		-	octa 
	0x5		-	Hexa-decimal
	5.0		-	double 
	5.0d 	-	double 
	5.0f 	-	float 
	5L		-	long 
	0b10	-	binary 

long 
----------------
class Test {

	public static void main(String[] args) {
		

		long x=10;
		System.out.println(Long.MAX_VALUE);
		System.out.println(Long.MIN_VALUE);
		System.out.println(Long.SIZE);
		System.out.println("10"+x);
		System.out.println(Long.parseLong("10")+x);
		System.out.println(x+50);
		System.out.println(Long.toString(x)+50);
		System.out.println(Integer.MAX_VALUE);
		long a = 9223372036854775807L;
		System.out.println(a);

	}
}

float and double 
------------------------
	class Test {

	public static void main(String[] args) {

		System.out.println(Float.MAX_VALUE);
		System.out.println(Float.MIN_VALUE);
		System.out.println(Float.SIZE);


		System.out.println(Double.MAX_VALUE);
		System.out.println(Double.MIN_VALUE);
		System.out.println(Double.SIZE);
	}
}

boolean 
----------------
	It holds true and false. 

	class Test {

	public static void main(String[] args) {

		boolean x = true;

		System.out.println(x);

		// boolean a = 1; // error 
		
	}
}

char 
----------------
	char support UNICODE in Java.
	UNICODE :	Universal Code 

	C/C++ support ASCII standard. 

	UNICODE is the combination of ASCII and local language Characters i.e. hindi/odia/telugu/...etc. 


// Print A...Z  and a...z
class Test {

	public static void main(String[] args) {
		
		for(int i=1000 ; i <= 2000 ; i++)
			System.out.print ((char)i +"\t");

		System.out.println("\n--------------------------------------\n");
		for(int i=97 ; i <= 122 ; i++)
			System.out.print ((char)i +"\t");
	}
}



How to use Ecplise 
------------------------------
	
	->	Download Ecplise from web (www.thetechpoint.in)
	->	Extract it 
	->	Open Ecplise application 
	->	Give the workspace location , Here workspace is container which store projects.
	->	File Menu 
	->	New 
	->	Click on Project 
	->	Click Java projects
	->	Next 
	->	Give Project Name (Example)
	->	Select (Use Default JRE ....)
	->	Finish 
	->	Don't Create / No 												'
	
	->	OPen the project 
	->	Click on Src  (Source Folder)
	-> RIGHT cLICK On Src 
	-> New 	
	-> class 
	-> Give class Name (Test)
	->	Finish 



public class Test {
	
public static void main(String[] args) {
		
		for(int i=2309 ; i <= 2360 ; i++)
			System.out.print ((char)i +"\t");
		
		System.out.println();
		
		for(int i=2821 ; i <= 2900 ; i++)
			System.out.print (i +"\t");

	}
}

public class Test {
	
	public static void main(String[] args) {
		
		System.out.println(Character.SIZE); // 16bits that means it can store 65536 characters

		System.out.println(Character.isUpperCase('A'));

		String name="Ritu Raj Anand 123";
		
		int digit=0, upper=0,lower=0,space=0,letter=0;
		for(int i=0 ; i < name.length() ; i++) {

			char ch=name.charAt(i);	//	charAt() method return the character at specified index 

			if(Character.isDigit(ch))
				digit++;
			if(Character.isUpperCase(ch))
				upper++;
			if(Character.isLowerCase(ch))
				lower++;
			if(Character.isLetter(ch))
				letter++;
			if(Character.isWhitespace(ch))
				space++;
		}
		System.out.println("No of Letters : "+letter);
		System.out.println("No of Uppercases : "+upper);
		System.out.println("No of Lowercases : "+lower);
		System.out.println("No of Digits : "+digit);
		System.out.println("No of Spaces : "+space);
	}
}

public class Test {
	
	public static void main(String[] args) {
		
		char ch='A';
		System.out.println(ch);
		System.out.println((int)ch);

		int x=10;
		int y=20;
		System.out.println(x+y);

		java.math.BigInteger n1 = new java.math.BigInteger("10000000000000000000000000000000000000000000000");
		java.math.BigInteger n2 = new java.math.BigInteger("20000000000000000000000000000000000000000000000");
		System.out.println(n1.add(n2));
		System.out.println(n1.multiply(n2));
		System.out.println(n1.divide(n2));
		System.out.println(n1.subtract(n2));

		System.out.println("--------------------------------------------");

		int f=1;
		for(int i=1; i <= 500 ; i++)
			f=f*i;
		System.out.println(f);

		System.out.println("--------------------------------------------");
		java.math.BigInteger f1 = new java.math.BigInteger("1");
		for(int i=1; i <= 500 ; i++)
			f1=f1.multiply(new java.math.BigInteger(""+i));
		System.out.println(f1);

		System.out.println("--------------------------------------");

		java.math.BigDecimal x1 = new java.math.BigDecimal("10.0");
		java.math.BigDecimal x2 = new java.math.BigDecimal("2.0");
		System.out.println(x1.add(x2));
		System.out.println(x1.multiply(x2));
		System.out.println(x1.divide(x2));
		System.out.println(x1.subtract(x2));

			
	}
}






Java Operators 
--------------------------------------------
	
	Java support 44 operators and divided into following types 

	x + y ;	//	Here x and y are known operand and + is known as operator 


	1.	Unary :	Operator which  only accept single operand. 

			+	-	++	--	~	!

	2.	Binary :	Operator which  only accept two operand. 

			Arithmetic 	:		+	-	*	/	% 
			Bitwise 	:		&	|	^ 
			Logical 	:		&&	|| 
			Shift 		:		>>	<<	>>>
			Relational 	:		>	<	>=	<=	==	!=	
			Assignment 	:		=	+=	-=	*=	/=	%=	>>=	<<=	>>>=	&=	|=	^=

	3.	Ternary :Operator which  only accept three operands. 

			?: 

	4.	Special : Used  for a special task 
			, 	.	instanceof  type  ()  []


+	-	++	--	~	!
=================================

	Unary plus (+)	and  Unary minus (-) are known as signed operator. 

	class Test {

	public static void main(String[] args) {
		

		int x = 10;
		System.out.println(x);
		System.out.println(-x);
		System.out.println(-+-+-x);
	}
}


++	-- 
-----------------
	
	Self updation operator.

	++		:	Self Increment 
	--		:	Self decrement 


	Self Increment and Self Decrement are two form 

		1.	Pre 	:	1st evaluate the expression then assign
						++x 
						--x;


		2.	Post 	:	1st assing then evaluate the expression
						x++;
						x--;

class Test {

	public static void main(String[] args) {
		
		int x = 5, y; 



		y = x++  + ++x + --x + x-- + ++x + --x ;

			

		System.out.println(x +"\t"+ y);
	}
}

~ (Complements )
----------------------
class Test {

	public static void main(String[] args) {
		
		System.out.println(~5);
		System.out.println(~-5);
	}
}
		00000101 		+5 
		11111010 		-6 


Note:	To findout the value of -ve binary, do 2's Complements. 
		
		11111010
		00000101
			  +1
		-----------
		00000110	=	-6


			OR 

		11111010
		00000110 	after 2's 


! (Not) operator
--------------------
	It always used with boolean value. 


	class Test {

	public static void main(String[] args) {
		
		System.out.println(!true);
		System.out.println(!false);
	}
}

Arithmetic 	:		+	-	*	/	% 
--------------------------------------------

+	operator having two form in Java 
	
	1.	+	:	Addition in case of non-string
	2.	+	:	concat in case of String 

Bitwise operator 	:	It evaluates the expression in binary level.
-----------------
	&	|	^	

	Rule for &		:	If both are true then return 1. 
	Rule for |		:	If anyone is true then return 1. 
	Rule for ^		:	If both are different then 1 


class Test {

	public static void main(String[] args) {
		
		System.out.println(10 & 9);
		System.out.println(10 | 9);
		System.out.println(10 ^ 9);

	}
}
D:\5-6>java Test.java
8
11
3

Logical operator
--------------------
	&&		|| 

	&&	:	If both are true then return true 
	||	:	If anyone is true then return true 


In case of  && , if first part is false , control doesnot check the 2nd part. 
In case of  || , if first part is true , control doesnot check the 2nd part. 

class Test {

	public static void main(String[] args) {
		
		int x = 10, y = 20;

		if(x++ > 1 || --y < 100) 
			System.out.println("If Part : "+x +"\t"+ y);
		else 
			System.out.println("Else Part : "+x +"\t"+ y);
	}
}

Shift operator
-----------------------------------------
	
	>>	(right shift)
	<< 	(left shift)
	>>> (unsigned right shift)


>>	(right shift)
-----------------------
	
	In case of +VE number Left most bits filled with 0
	In case of -VE number Left most bits filled with 1

	Technique 
	----------------
	+ve No / 2^shifted_bits 
	floor(-ve No / 2^shifted_bits) 


<<	(left shift)
-----------------------
	
	In case of +VE number Right most bits filled with 0
	In case of -VE number Left most bits filled with 0

	Technique 
	----------------
	+ve No * 2^shifted_bits 
	-ve No * 2^shifted_bits

>>> (unsigned right shift)
--------------------
	
	It only work with -VE number and Left most bits filled with 0



class Test {

	public static void main(String[] args) {
		
		System.out.println(10 >> 2);
		System.out.println(10 << 2);
	}
}

00000000	00000000	00000000 	00001010
00 00000000	00000000	00000000 	000010

00000000	00000000	00000000 	00001010
000000	00000000	00000000 	0000101000


Floor 
----------
	-2.0	=	-2
	-2.1	=	-3
	-2.9	=	-3	

class Test {

	public static void main(String[] args) {
		
		System.out.println(100 >> 3);
		System.out.println(100 << 3);

		System.out.println(-10 >> 2);
	}
}






Java Operators 
--------------------------------------------
	
	Java support 44 operators and divided into following types 

	x + y ;	//	Here x and y are known operand and + is known as operator 


	1.	Unary :	Operator which  only accept single operand. 

			+	-	++	--	~	!

	2.	Binary :	Operator which  only accept two operand. 

			Arithmetic 	:		+	-	*	/	% 
			Bitwise 	:		&	|	^ 
			Logical 	:		&&	|| 
			Shift 		:		>>	<<	>>>
			Relational 	:		>	<	>=	<=	==	!=	
			Assignment 	:		=	+=	-=	*=	/=	%=	>>=	<<=	>>>=	&=	|=	^=

	3.	Ternary :Operator which  only accept three operands. 

			?: 

	4.	Special : Used  for a special task 
			, 	.	instanceof  type  ()  []


+	-	++	--	~	!
=================================

	Unary plus (+)	and  Unary minus (-) are known as signed operator. 

	class Test {

	public static void main(String[] args) {
		

		int x = 10;
		System.out.println(x);
		System.out.println(-x);
		System.out.println(-+-+-x);
	}
}


++	-- 
-----------------
	
	Self updation operator.

	++		:	Self Increment 
	--		:	Self decrement 


	Self Increment and Self Decrement are two form 

		1.	Pre 	:	1st evaluate the expression then assign
						++x 
						--x;


		2.	Post 	:	1st assing then evaluate the expression
						x++;
						x--;

class Test {

	public static void main(String[] args) {
		
		int x = 5, y; 



		y = x++  + ++x + --x + x-- + ++x + --x ;

			

		System.out.println(x +"\t"+ y);
	}
}

~ (Complements )
----------------------
class Test {

	public static void main(String[] args) {
		
		System.out.println(~5);
		System.out.println(~-5);
	}
}
		00000101 		+5 
		11111010 		-6 


Note:	To findout the value of -ve binary, do 2's Complements. 
		
		11111010
		00000101
			  +1
		-----------
		00000110	=	-6


			OR 

		11111010
		00000110 	after 2's 


! (Not) operator
--------------------
	It always used with boolean value. 


	class Test {

	public static void main(String[] args) {
		
		System.out.println(!true);
		System.out.println(!false);
	}
}

Arithmetic 	:		+	-	*	/	% 
--------------------------------------------

+	operator having two form in Java 
	
	1.	+	:	Addition in case of non-string
	2.	+	:	concat in case of String 

Bitwise operator 	:	It evaluates the expression in binary level.
-----------------
	&	|	^	

	Rule for &		:	If both are true then return 1. 
	Rule for |		:	If anyone is true then return 1. 
	Rule for ^		:	If both are different then 1 


class Test {

	public static void main(String[] args) {
		
		System.out.println(10 & 9);
		System.out.println(10 | 9);
		System.out.println(10 ^ 9);

	}
}
D:\5-6>java Test.java
8
11
3

Logical operator
--------------------
	&&		|| 

	&&	:	If both are true then return true 
	||	:	If anyone is true then return true 


In case of  && , if first part is false , control doesnot check the 2nd part. 
In case of  || , if first part is true , control doesnot check the 2nd part. 

class Test {

	public static void main(String[] args) {
		
		int x = 10, y = 20;

		if(x++ > 1 || --y < 100) 
			System.out.println("If Part : "+x +"\t"+ y);
		else 
			System.out.println("Else Part : "+x +"\t"+ y);
	}
}

Shift operator
-----------------------------------------
	
	>>	(right shift)
	<< 	(left shift)
	>>> (unsigned right shift)


>>	(right shift)
-----------------------
	
	In case of +VE number Left most bits filled with 0
	In case of -VE number Left most bits filled with 1

	Technique 
	----------------
	+ve No / 2^shifted_bits 
	floor(-ve No / 2^shifted_bits) 


<<	(left shift)
-----------------------
	
	In case of +VE number Right most bits filled with 0
	In case of -VE number Left most bits filled with 0

	Technique 
	----------------
	+ve No * 2^shifted_bits 
	-ve No * 2^shifted_bits

>>> (unsigned right shift)
--------------------
	
	It only work with -VE number and Left most bits filled with 0



class Test {

	public static void main(String[] args) {
		
		System.out.println(10 >> 2);
		System.out.println(10 << 2);
	}
}

00000000	00000000	00000000 	00001010
00 00000000	00000000	00000000 	000010

00000000	00000000	00000000 	00001010
000000	00000000	00000000 	0000101000


Floor 
----------
	-2.0	=	-2
	-2.1	=	-3
	-2.9	=	-3	

class Test {

	public static void main(String[] args) {
		
		System.out.println(100 >> 3);
		System.out.println(100 << 3);

		System.out.println(-10 >> 2);
	}
}

Relational 	:		>	<	>=	<=	==	!=	
------------------------------------------------------
	These operators are used to check the condition and return true or false value. 

	class Test {

	public static void main(String[] args) {
		
		System.out.println(10 > 2); 
		System.out.println(10 < 2); 
		System.out.println(10 == 2); 
		System.out.println(10 != 2); 
		System.out.println(10 >= 2); 
		System.out.println(10 <= 2); 
	}
}

D:\5-6>java Test
true
false
false
true
true
false

Assignment 	:		=	+=	-=	*=	/=	%=	>>=	<<=	>>>=	&=	|=	^=
------------------------------------------------------------------------------
	
	These operators are used to assign a value to variable. 

	+=	-=	*=	/=	%=	>>=	<<=	>>>=	&=	|=	^= are known as short-hand operators.


	x = x+2;
	x += 2 ;	

	There is no difference from output point of view, but there is a big difference from type-casting point of view. 

	x = x+2;	//	Here type-casting has to be done by programmer 
	x += 2 ; // Here type-casting implicitly done by compiler. 

	class Test {

	public static void main(String[] args) {
		
		byte x = 10;

		x = (byte) (x+2);	//	Here 12 will be assigned to x 
		System.out.println(x);

		x += 2 ;	//	Meaning of this statement is x = x+2
		System.out.println(x);

		x >>= 2;  //	x = x >> 2
		System.out.println(x); 

	}
}


Ternary operators ( ? : )
--------------------------------------------------
	
	It is known as conditional operator. 
	It is the replacement of if..else. 

	class Test {

	public static void main(String[] args) {
		
		String message = 10 > 2 ? "Yes 10 is greater" : "No 2 is big";
		System.out.println(message);

		if(10>2)
			System.out.println("10 is greater");
		else
			System.out.println("2 is big");
	}
}

Special operators
---------------------------------
	, 	.	instanceof  type  ()  []

	,	(comma)	:	It is known as separator 
	int a , b , c ;


	.(dot) operator
	-------------------
		It is used to access variable/class/package/object/function/...etc. 

class Test {

	public static void main(String[] args) {
		
		java.lang.System.out.println(Integer.SIZE);
	}
}

java.lang.	-	package accessing 
lang.System.-	class accessing
System.out 	-	object accessing
out.println()-	function accessing 
Integer.SIZE -	variable accessing 

instanceof
--------------------
	It is used to check the object existence and return boolean value. 

	class Test {

	public static void main(String[] args) {
		
		Test t1 = new Test ();
		Test t2 = new Test ();
		
		System.out.println(t1 instanceof Test);
		System.out.println(t2 instanceof Test);
	}
}

type 
-------------------
	It is known as type-casting operator. 

	Two types of type-casting 

		1.	Implicit type-casting

				Here compiler implicitly cast the right side value/variable according to the requirement of left-side operand.

				If you are assigning a smaller type of data to a larger type . 

				byte x = 10;
				int y =  x; 

				Note : Here memory loss 


		2.	Explicit type-casting

				If you are assigning a larger type of data to a smaller type , then Explicit type-casting is required. 

				int x = 10;
				byte y = x; // error 
				byte y = (byte) x;  // Here type-casting is mandotory 


				Note:	Here data may loss 


	
	()  	:	It is used with function / constructor 

	[] 		:	It is used with array. 


---------------------------------------------------------------------------
Java Introduction 
Features 
Hello World Program 
Datatypes/Wrapper-class 
Operators in Java 


In Java, we can store following types of member within a class 
	
	1.	Variables / Data member 
	2.	Block member 
	3.	Function / Method Member 
	4.	Constructor member 

Variable in Java 
----------------------------
	Java support 6 types of variable

		1.	Local 
		2.	Static 	/ class-level variable
		3.	Non-static  / instance / object-level 
		4.	Final  / constant 
		5.	transient 
		6.	volatile 

Local variable 
-------------------------------
	If the variable is declared within any block except the block of class directly. 
	Local variable should be initialized before using. 
	The scope of Local variable only within that block in which it is declared, so no access specifiers are not allowed. 


	class Test {

	static int  a = 10;  // static variable 
	int b = 20;			//	non-static variable 
	final int c = 30; 	// final variable 
	transient int d = 40; //	transient variable 
	volatile int e = 50;	//	volatile variable 

	
	public static void main(String[] args) {
		

		int f = 60; // Local 
	}
}


class Test {


	public static void main(String[] args) {
		

		int a = 60, b ; // Local 
		System.out.println(a);
		//System.out.println(b); // error

		b=111;
		System.out.println(b);

		// public int c = 99; // error
	}
}





static variable
-----------------------------------
	If the variable is declared with static keyword, then it is known as static variable or class level variable. 

	Why static variable is known as class level variable ? 

	static variable allocates memory at the time of class loading, so it is known as class level variable, and static variable reserves memory only for a single time. 

	D:\5-6>java  Test //  Here .class file will be executed by JVM.

	Here , first Test.class will be loaded into JVM i.e. known as class loading. 
	class loading always occurs only for a single time. 


	Without initialization, static variable holds the default value of datatype. 

	static variable can be called by 

		->	class name 
		->	object name 
		->	directly (Possible within same class only)


class Test {

	static int x = 100, y;

	public static void main(String[] args) {
		
		System.out.println(y);

		Test t1 = new Test();
		Test t2 = new Test();

		System.out.println(x +"\t"+ Test.x +"\t"+ t1.x +"\t"+ t2.x);
		t1.x=200;
		System.out.println(x +"\t"+ Test.x +"\t"+ t1.x +"\t"+ t2.x);
		x=300;
		System.out.println(x +"\t"+ Test.x +"\t"+ t1.x +"\t"+ t2.x);
		Test.x=400;
		System.out.println(x +"\t"+ Test.x +"\t"+ t1.x +"\t"+ t2.x);
		
		
	}
}


Non-static variable / instance variable / object level variable
---------------------------------------------------------------------
	If the variable is declared without static keyword , then it is known as Non-static variable / instance variable / object level variable.

	Non-static variable always allocates memory at the time of object creation, so it is known as object level variable.

	It creates a separate copy for each and every object. 

	Non-static variable only can be called by object name. 

class Test {

	int x = 100, y;

	public static void main(String[] args) {
		
		
		Test t1 = new Test();
		Test t2 = new Test();

		System.out.println(t1.y);

		System.out.println(t1.x +"\t"+ t2.x);
		t1.x=200;
		System.out.println(t1.x +"\t"+ t2.x);
		t2.x=300;
		System.out.println(t1.x +"\t"+ t2.x);
		
	}
}

Final variable 
------------------------------
	If the variable is declared with final keyword, then it is known as constant in Java. 
	Constant means value cannot be changed. 

	Final variable should be initialized at the time of declaration. 


class Test {

	final static int x = 100;

	public static void main(String[] args) {
		
		
		Test t1 = new Test();
		Test t2 = new Test();

		System.out.println(t1.x +"\t"+ t2.x);

		//t1.x=200;//error 

	}
}


Block member 
------------------------------
	Java support two types of block.

	1.	static block
	2.	Non-static block 


static block 
---------------
	If the block is declared with static keyword , then it is known as static block. 

	static {

		//	Code Goes Here 
	}

	static block always execute before main() method called by JVM, so static block can be executed only for a single time. 


class Test {

	static {

		System.out.println("Hello");
	}

	public static void main(String[] args) {
		
		System.out.println("Hi");
	}

	static {

		System.out.println("Bye");
	}
}

Non-static block 
---------------
	If the block is declared without static keyword , then it is known as non-static block. 

	{

		//	Code Goes Here 
	}

	Non-static block always execute before object creation, so it can be exdecuted zero or multiple times. 

class Test {

	Test () {

		System.out.println("Constructor ");
	}

	public static void main(String[] args) {
		
		System.out.println("Hi");

		Test t1 = new Test(); // object creation means constructor invocation 

		System.out.println("Ok");
	}
}


---------------------------

class Test {

	Test () {

		System.out.println("Constructor ");
	}

	public static void main(String[] args) {
		
		System.out.println("Hi");

		Test t1 = new Test(); // object creation means constructor invocation 

		System.out.println("Ok");
	}

	{

		System.out.println("Java");
	}
}


-------------------------------------

class Test {

	static {

		System.out.println("Hello");
	}

	Test () {

		System.out.println("Constructor ");
	}

	public static void main(String[] args) {
		
		System.out.println("Hi");

		Test t1 = new Test(); // object creation means constructor invocation 
		Test t2 = new Test(); // object creation means constructor invocation 

		System.out.println("Ok");
	}

	{

		System.out.println("Java");
	}
}





java.math.BigInteger n1 = new java.math.BigInteger("10000000");
I am unable to get this line ......Please suggest me0

Constructor of BigInteger class always accept a String as an argumnet. 

java.math.BigInteger f1 = new java.math.BigInteger("1");
		for(int i=1; i <= 500 ; i++)
			f1=f1.multiply(new java.math.BigInteger(""+i));
		System.out.println(f1);
also these codes.........in place of (new java.math.BigInteger(""+i)); can we write simple f1.multiply( i );

multiply() function always accept the object of BigInteger class i.e. multiply(BigInteger).

Java Methods/Functions 
-----------------------------
	
	Collection of java codes , which is responsible to perform a specific task or functionality is known as function. 


	Function having three different parts 

		1.	Function Declaration 

				int fact(int);

		2.	Function design 

				int fact(int num) {

					//Code Goes Here
				}

		3.	Function calling 

				fact(5);

Types of method 
-----------------------
	
	1.	static method 
	2.	non-static method 
	3.	final method 
	4.	abstract method 
	5.	native method 
	6.	synchronized method 

static and non-static method 
----------------------------------------

	If the method is declared with static keyword then it is known as static method. 
	If the method is declared without static keyword then it is known as non-static method. 

	static method can be called by 
		class name 
		object name 
		directly 
	non-static method can be called by 
		object name 
	

	Calling Procedure 
	-------------------

										To static member 					To non-static member 
										(variable/function)					(variable/function)



From static context 				directly/class-name/object-name			object-name 
(method/block)

From Non-static context 			directly/class-name/object-name			directly/object-name 
(method/block/constructor)

class Test {

	static int x = 10;
	int y = 20;

	void show() {	// non-static method 

		System.out.println("Within show() method ");
		System.out.println(x);
		System.out.println(y);
	}
	public static void main(String[] args) { // static method 
		
		Test t = new Test ();

		System.out.println("main() method ");
		System.out.println(x);
		//System.out.println(y); // error : non-static variable y cannot be referenced from a static context
		System.out.println(t.y);

		t.show();
	}
}

Program :	Write a java program to check the number is Even or Odd using static function. 
			Write a java program to counts the number of bit is ON/OFF using non-static function. 
			Findout factorial of a number using static method. 
			Check the number is prime or not using non-static function. 


Final method 
---------------------------

	In Java, final is a keyword which can be used 

		->	to declare a constant i.e. final variable which cannot be modified 
		->	final method : Overriding is not possible 
		->	final class :	Cannot be inherited. 


Final method 
------------------------
	If the method is decalred with final keyword , then it known as final method. 
	Final method cannot Override. 

	What is Method Overriding ? 

	When a method re-design within the child class then it is known as method Overriding. In this case , method name , argument and  return type must be same in both parent and child class. 

	For method Overriding , inheritance is must required. 


/*
	extends is keyword in java, which is used to create inheritance. 
	In case of inheritance, one class behaves like parent class and another class behaves like child class. 
	In the following example, vehicle is the parent class and Cycle is the child class. 
	
	In inheritance, the child class can access the resource of parent class. 

*/
class Vehicle {

	void run () {
		System.out.println("Vehicle is running safely with the speed 50");
	}
}
class Cycle extends Vehicle {

	public static void main(String[] args) {
		
		Cycle c1 = new Cycle ();
		c1.run();
	}
}


-----------------------------------


class Vehicle {

	void run () {
		System.out.println("Vehicle is running safely with the speed 50");
	}
}
class Cycle extends Vehicle {

	void run () {
		System.out.println("Cycle is running safely with the speed 10");
	}

	public static void main(String[] args) {
		
		Cycle c1 = new Cycle ();
		c1.run();
	}
}


----------------------------------------
/*
	extends is keyword in java, which is used to create inheritance. 
	In case of inheritance, one class behaves like parent class and another class behaves like child class. 
	In the following example, vehicle is the parent class and Cycle is the child class. 
	
	In inheritance, the child class can access the resource of parent class. 

*/
class Vehicle {

	final void run () {
		System.out.println("Vehicle is running safely with the speed 50");
	}
}
class Cycle extends Vehicle {

	void run () { //  run() in Cycle cannot override run() in Vehicle
		System.out.println("Cycle is running safely with the speed 10");
	}

	public static void main(String[] args) {
		
		Cycle c1 = new Cycle ();
		c1.run();
	}
}


Final class cannot inherited
-------------------------------
	class A {

}
final class B extends A {

}
class C extends B { //  error: cannot inherit from final B

}





abstract method 
---------------------------
	If the method is declared with abstract keyword then it is known as abstract method in java. 

	abstract void fact();

	abstract method cannot have a body. 

	abstract method is used to declare a function i.e. function prototype. 

	If any method of a class is declared as abstract, then coresponding class should be declared as abstract class.

	Example: abstract method and abstract class 
	----------------------------------------------

	abstract class Test {

	abstract void show() ;


	void display () {  // complete/concrete method 

		System.out.println("display() method within Test class");
	}


	public static void main(String[] args) {
		
		System.out.println("Welcome to Abstraction");

	}
}



Suppose a project contains 500 functionlities. 

Library Management System 
-----------------------------
	void studentLogin() 
	void studentLogout()
	void teacherLogin() 
	void teacherLogout() 
	void fineCalculate()
	void changePasswordStudent()
	void changePasswordTeacher() 
	.....
	.....

To complete all the functionlities, required 5 months. 

To develop a project , as a developer you have to create  a model or prototype.  

What are things u have to perfome in project , u should declare first and at the time of developing the project develop accordingly. 


Abstraction :	Hide the unncessary details to end user. 

In Java, Abstraction can be achieved by two ways 
	
	1.	Abstract class 
	2.	Interface 


Abstract class cannot be instantiated i.e. object cannot be created directly. 

We can create the object of abstract class indirectly by two ways 
	
	1.	By inheritance 
	2.	By Anonymous class 


complete / concrete method :	Method with body. 
complete / concrete class  :	Class without abstract keyword

abstract method :	Method with abstract keyword and  without body.
abstract class  :	Class with abstract keyword. 

Complete class should satisfy following two rules 
	
	1.	It should not contains any abstract method. 
	2.	It is compulsory to Override all the abstract methods which are present in super abstract class. 

Example:	How to create the object of abstract class with the help of inheritance
--------------------------------------------------------------------------------------
	Step 1  :	Design a sub-class of abstract class. 
	Step 2  : 	Override all the abstract methods of abstract class within the sub-class 
	Step 3  : 	Create the object of child class and that object can be treated as the object of abstract class . 
	Step 4  : 	With the help of child class object, call the resources of parent class. 


abstract class Test {

	abstract void show() ;
	abstract void doAdd(int a, int b);

	void display() {
		System.out.println("display() within Test class");
	}
}
class Demo extends Test {

	void doAdd(int a, int b) {

		System.out.println("After Add : "+(a+b));
	}
	void show() {

		System.out.println("show() method within Demo class ");
	}
	public static void main(String[] args) {
		
		// Test t = new Test ();	//	Error Test is abstract; cannot be instantiated
		Demo d = new Demo();
		d.doAdd(100,200);
		d.show();
		d.display();

	}
}


Anonymous class 
---------------------------------
	Class without any name is known as Anonymous class. 

	In otherwords, when a java programmer provides a body to an object then javac compiler will create a .class file automatically, i.e. known as Anonymous class.






abstract method 
---------------------------
	If the method is declared with abstract keyword then it is known as abstract method in java. 

	abstract void fact();

	abstract method cannot have a body. 

	abstract method is used to declare a function i.e. function prototype. 

	If any method of a class is declared as abstract, then coresponding class should be declared as abstract class.

	Example: abstract method and abstract class 
	----------------------------------------------

	abstract class Test {

	abstract void show() ;


	void display () {  // complete/concrete method 

		System.out.println("display() method within Test class");
	}


	public static void main(String[] args) {
		
		System.out.println("Welcome to Abstraction");

	}
}



Suppose a project contains 500 functionlities. 

Library Management System 
-----------------------------
	void studentLogin() 
	void studentLogout()
	void teacherLogin() 
	void teacherLogout() 
	void fineCalculate()
	void changePasswordStudent()
	void changePasswordTeacher() 
	.....
	.....

To complete all the functionlities, required 5 months. 

To develop a project , as a developer you have to create  a model or prototype.  

What are things u have to perfome in project , u should declare first and at the time of developing the project develop accordingly. 


Abstraction :	Hide the unncessary details to end user. 

In Java, Abstraction can be achieved by two ways 
	
	1.	Abstract class 
	2.	Interface 


Abstract class cannot be instantiated i.e. object cannot be created directly. 

We can create the object of abstract class indirectly by two ways 
	
	1.	By inheritance 
	2.	By Anonymous class 


complete / concrete method :	Method with body. 
complete / concrete class  :	Class without abstract keyword

abstract method :	Method with abstract keyword and  without body.
abstract class  :	Class with abstract keyword. 

Complete class should satisfy following two rules 
	
	1.	It should not contains any abstract method. 
	2.	It is compulsory to Override all the abstract methods which are present in super abstract class. 

Example:	How to create the object of abstract class with the help of inheritance
--------------------------------------------------------------------------------------
	Step 1  :	Design a sub-class of abstract class. 
	Step 2  : 	Override all the abstract methods of abstract class within the sub-class 
	Step 3  : 	Create the object of child class and that object can be treated as the object of abstract class . 
	Step 4  : 	With the help of child class object, call the resources of parent class. 


abstract class Test {

	abstract void show() ;
	abstract void doAdd(int a, int b);

	void display() {
		System.out.println("display() within Test class");
	}
}
class Demo extends Test {

	void doAdd(int a, int b) {

		System.out.println("After Add : "+(a+b));
	}
	void show() {

		System.out.println("show() method within Demo class ");
	}
	public static void main(String[] args) {
		
		// Test t = new Test ();	//	Error Test is abstract; cannot be instantiated
		Demo d = new Demo();
		d.doAdd(100,200);
		d.show();
		d.display();

	}
}


Anonymous class 
---------------------------------
	Class without any name is known as Anonymous class. 

	In otherwords, when a java programmer provides a body to an object then javac compiler will create a .class file automatically, i.e. known as Anonymous class. 
	
	syntax 
	---------

		Test t1 = new Test () ; //	Normal object 

		Test t2 = new Test () {	//	Anonymous class 

			// Body Part 
		};


class Test {

	public static void main(String[] args) {
		
		Test t1 = new Test ();

		Test t2 = new Test (){
		};

		Test t3 = new Test (){
		};

		Test t4 = new Test (){
		};

		System.out.println("Anonymous class ");
	}
}

Note:	In the above program, javac compiler will create four .class file 
	

			1.	Test.class 
			2.	Test$1.class 
			3.	Test$2.class 
			4.	Test$3.class 

Example: Anonymous class 
---------------------------------

class A {

}
class B {

}
class Test {

}
class Demo {

	public static void main(String[] args) {
		
		A a1 = new A () {
		};

		B b1 = new B () {
		};

		Test t1 = new Test () {

		};

		System.out.println("Anonymous class ");
	}
}




Note:	In the above program, javac compiler will create following .class files
	

			1.	A.class
			2.	B.class 
			3.	Test.class 
			4.	Demo.class 

			5.	Demo$1.class  extends A 
			6.	Demo$2.class  extends B
			7.	Demo$3.class  extends Test

Example: Anonymous class 
-------------------------------------------------------

class Test {

	void show() {

		System.out.println("show() : Test.class ");
	}
	public static void main(String[] args) {
		
		Test t1 = new Test ();	//	Here t1 is the object of Test class 
		t1.show();

		Test t2 = new Test (){	//	Here t2 is the object of Test$1.class and Test$1 is the sub-class of Test.class
		};
		t2.show();

		Test t3 = new Test (){	//	Here t3 is the object of Test$2.class
			
			void show() {
				System.out.println("show() : Test$2.class");
			}
		};
		t3.show();

	}
}



Example: Anonymous class in case of Abstraction
---------------------------------------------------
abstract class  Demo {

	abstract void doAdd();
}
class A {

	public static void main(String[] args) {
		
		Demo d1 = new Demo() {

			void doAdd () {
				System.out.println("Logic of int Addition");
			}
		};

		Demo d2 = new Demo() {

			void doAdd () {
				System.out.println("Logic of double Addition");
			}
		};

		d1.doAdd();
		d2.doAdd();
	}
}

--------------------------------------------------------------------------------
class A$1 extends Demo {

	void doAdd () {
				System.out.println("Logic of int Addition");
			}
}
class A$2 extends Demo {

	void doAdd () {
				System.out.println("Logic of double Addition");
			}
}






Native Method 
---------------------------
	If the method is declared with native keyword, then it is known as native method in java. 
	native method is used to communicate java language with other enviorment like C/C++.
	In otherwords, native method is used to interact with system software. 

	Steps to create a native application 
	------------------------------------

		1.	Create the java program (Test.java)
		2.	Compile the java program and create header file (.h) & class file (.class)
		3.	Open the header file (Test.h) and copy the function prototype related to fact() method 
		4.	Create a C program (demo.c) within copied function prototype
		5.	Set the path of  JAVA_HOME
		6.	Compile the C program
		7.	Create the libraray (lit.dll) from demo.o file 
		8.	Execute the java program , which will execute C program


1.	Create the java program (Test.java)
-----------------------------------------------------
		
class Test {

	native void fact();

	public static void main(String[] args) {
		
		Test t = new Test ();
		t.fact(); // Here we are calling the fact() method 
	}

	static {

		System.loadLibrary("lit"); 
	}
}


/*
	Note:

	In the above program , fact() is a native method.
	If the method is native , compiler doesnot check the method existence at the time of compilation, always check at run-time.
	Native method also indicates , function will be designed in C/C++ but java programmer is calling from java enviorment.

	loadLibrary() is a static method of System class , which is used to load the library into JVM.
	In the above program , "lit" is the user-defined library name.
*/


2.	Compile the java program and create header file (.h) & class file (.class)
---------------------------------------------------------------------------------
	
	D:\5-6>javac  -h   .   Test.java



	Note:	The above command will create two files 

				->	Test.class 
				->	Test.h

			-h 		:	It is used to create header file 
			. 		:	It indicates current directory/folder i.e. Test.class and Test.h will be created within 5-6 folder. 


3.	Open the header file (Test.h) and copy the function prototype related to fact() method 
---------------------------------------------------------------------------------------------
	
	JNIEXPORT void JNICALL Java_Test_fact (JNIEnv *, jobject);

4.	Create a C program (demo.c) and write the logic of C program within copied function prototype
--------------------------------------------------------------------------------------------------
	#include "Test.h"
#include "jni.h"

JNIEXPORT void JNICALL Java_Test_fact (JNIEnv *x, jobject y) {

	// Logic of C Program put HERE 
	int num , f = 1 , i =1 ;
	printf("Enter into C env... \n");
	printf("Enter a Number ....\n");
	scanf("%d",&num);
	for (i = 1 ; i <= num ; i++)
	{
		f = f * i ;
	}
	printf("Fact is %d : \n",f);
	printf ("Exit from C env & enter into java ... \n");
}


5.	Set the path of  JAVA_HOME
------------------------------------------------
	
	D:\5-6>set JAVA_HOME=C:\Program Files\Java\jdk-14.0.1	

6.	Compile the C program
------------------------------------

		D:\5-6>gcc -c -I"%JAVA_HOME%\include" -I"%JAVA_HOME%\include\win32" demo.c

		gcc 			-	C compiler name 
		-c 				-	compilation 
		-I 				-	interaction 
		%JAVA_HOME%		-	C:\Program Files\Java\jdk-14.0.1
		include 		-	Within include folder jni.h file available 
		win32 			-	jni.h internally use jni_md.h and jni_md.h present in win32 folder. 
	

	Note:	The above command will create demo.o object file.

7.	Create the libraray (lit.dll) from demo.o file 
------------------------------------------------------------
	
	D:\5-6>gcc -Wl,--add-stdcall-alias -shared -o lit.dll demo.o

	Note:	The above command will create lit.dll library file 
			dll (dynamic linking library)


8.	Execute the java program , which will execute C program automatically
--------------------------------------------------------------
	
D:\5-6>java Test
Enter into C env...
Enter a Number ....
5
Fact is 120 :
Exit from C env & enter into java ...







Constructor in Java 
-----------------------------------
	Constructor is very similar to method, and it is used to initialize the object. 

	Method vs Constructor
	---------------------

	Name 	:	Name of the method may or maynot be same with the class name whereas Constructor name should be same as the class name. 


	Return Type :  Return type is mandotory for a method whereas return type is not allowed with Constructor. 


	Overriding :  Java support Method Overriding  whereas Constructor cannot Override. 


	Types : 	Java support 6 types of method whereas support 2 types of Constructor

	Calling Procedure : Method can be called by class name / object name or directly whereas Constructor can be called by new/this or super keyword. 

	Modifiers :	Method can be declared with static/abstract/native/final/synchronized whereas these modifiers are not allowed with Constructor. 


class Test {

	static void Test()  {

		System.out.println("Test() method");
	}

	Test () {

		System.out.println("Test() constructor ");
	}
	public static void main(String[] args) {
		
		Test();	//	calling directly means method 
		Test.Test();	 //	calling by class name means method 
		Test t = new Test();	//	calling by new means constructor
		t.Test(); 	 //	calling by object means method 
	}
}

Types of constructor
---------------------------

	Java support two types of constructor 

		1.	Default : When a java programmer doesnot define any constructor within a class then javac compiler automatically provide a constructor for object creating i.e. known as default constructor. 

			Default constructor is always no argument type. 

			Access specifier is always same with the Access specifier of the class. 

			Example: 

			class Test {

			}

			D:\5-6>javac Test.java

			D:\5-6>javap Test
			Compiled from "Test.java"
			class Test {
			  Test();
			}

			Example: 
			public class Test {

			}

			D:\5-6>javac Test.java

			D:\5-6>javap Test
			Compiled from "Test.java"
			public class Test {
			  public Test();
			}



		2.	Parameterized : The constructor which is designed by programmer within a class , it is known as Parameterized constructor. 

		public class Test {

	Test() {

		System.out.println("Test() without argument ");
	}
	Test(int x) {

		System.out.println("Test() with int argument ");
	}
	Test(String x) {

		System.out.println("Test() with String argument ");
	}
	public static void main(String[] args) {
		
		Test t = new Test();
		new Test(123);
		new Test("Hello");
	}
}

D:\5-6>javac Test.java

D:\5-6>java Test
Test() without argument
Test() with int argument
Test() with String argument

Note: 	If Parameterized constructor is already developed by developer then default constructor is not given by compiler. 

public class Test {

	Test(int x) {
		
	}
	public static void main(String[] args) {

		new Test();
		new Test(123);
	}
}

----------------------

Sir, what is the use of constructors? If it's working the same as methods
------------------------------------------------------------------------------

class Student {

	int roll ; 
	String branch;

	Student (int r , String b) {

		//	following is the code for object initialization 
		roll=r;
		branch=b;
	}
	public static void main(String[] args) {
		
		Student raja = new Student (1234,"CSE");
		Student rani = new Student (1235,"Mech");
		
		System.out.println("Details of Raja : "+raja.roll +"\t"+raja.branch);
		System.out.println("Details of Rani : "+rani.roll +"\t"+rani.branch);
			
	}
}

Constructor with Access Specifier 
----------------------------------
public class Test {

	public int a ; 
	protected int b; 
	int c ; 
	private int d ; 

	private Test () {

		System.out.println("Private constructor");
	}
	protected Test(int x) {

		System.out.println("Protected constructor");
	}
	Test(String s) {

		System.out.println("Default constructor");
	}
	public Test (long k) {

		System.out.println("Public constructor ");
	}
	public static void main(String[] args) {
		
		new Test(100);
		new Test(100L);
		new Test("100");
		new Test();
	}
}


Reference and Object 
-------------------------------------------
	Object is the collection of sequence set of bytes. 
	Size of the object in java is 16bytes by default. 
	Out of 16bytes, 12 bytes already used as object header. 
	Block size of the object is always 8 bytes. 

	Test t = new Test ();	//	size of t is 16 bytes by default. 

	static and local memners are not part of java object. 

	Calling the constructor by new keyword , means






[4:43 PM, 1/12/2021] +91 99379 17604: Constructor in Java 
-----------------------------------
	Constructor is very similar to method, and it is used to initialize the object. 

	Method vs Constructor
	---------------------

	Name 	:	Name of the method may or maynot be same with the class name whereas Constructor name should be same as the class name. 


	Return Type :  Return type is mandotory for a method whereas return type is not allowed with Constructor. 


	Overriding :  Java support Method Overriding  whereas Constructor cannot Override. 


	Types : 	Java support 6 types of method whereas support 2 types of Constructor

	Calling Procedure : Method can be called by class name / object name or directly whereas Constructor can be called by new/this or super keyword. 

	Modifiers :	Method can be declared with static/abstract/native/final/synchronized whereas these modifiers are not allowed with Constructor. 


class Test {

	static void Test()  {

		System.out.println("Test() method");
	}

	Test () {

		System.out.println("Test() constructor ");
	}
	public static void main(String[] args) {
		
		Test();	//	calling directly means method 
		Test.Test();	 //	calling by class name means method 
		Test t = new Test();	//	calling by new means constructor
		t.Test(); 	 //	calling by object means method 
	}
}

Types of constructor
---------------------------

	Java support two types of constructor 

		1.	Default : When a java programmer doesnot define any constructor within a class then javac compiler automatically provide a constructor for object creating i.e. known as default constructor. 

			Default constructor is always no argument type. 

			Access specifier is always same with the Access specifier of the class. 

			Example: 

			class Test {

			}

			D:\5-6>javac Test.java

			D:\5-6>javap Test
			Compiled from "Test.java"
			class Test {
			  Test();
			}

			Example: 
			public class Test {

			}

			D:\5-6>javac Test.java

			D:\5-6>javap Test
			Compiled from "Test.java"
			public class Test {
			  public Test();
			}



		2.	Parameterized : The constructor which is designed by programmer within a class , it is known as Parameterized constructor. 

		public class Test {

	Test() {

		System.out.println("Test() without argument ");
	}
	Test(int x) {

		System.out.println("Test() with int argument ");
	}
	Test(String x) {

		System.out.println("Test() with String argument ");
	}
	public static void main(String[] args) {
		
		Test t = new Test();
		new Test(123);
		new Test("Hello");
	}
}

D:\5-6>javac Test.java

D:\5-6>java Test
Test() without argument
Test() with int argument
Test() with String argument

Note: 	If Parameterized constructor is already developed by developer then default constructor is not given by compiler. 

public class Test {

	Test(int x) {
		
	}
	public static void main(String[] args) {

		new Test();
		new Test(123);
	}
}

----------------------

Sir, what is the use of constructors? If it's working the same as methods
------------------------------------------------------------------------------

class Student {

	int roll ; 
	String branch;

	Student (int r , String b) {

		//	following is the code for object initialization 
		roll=r;
		branch=b;
	}
	public static void main(String[] args) {
		
		Student raja = new Student (1234,"CSE");
		Student rani = new Student (1235,"Mech");
		
		System.out.println("Details of Raja : "+raja.roll +"\t"+raja.branch);
		System.out.println("Details of Rani : "+rani.roll +"\t"+rani.branch);
			
	}
}

Constructor with Access Specifier 
----------------------------------
public class Test {

	public int a ; 
	protected int b; 
	int c ; 
	private int d ; 

	private Test () {

		System.out.println("Private constructor");
	}
	protected Test(int x) {

		System.out.println("Protected constructor");
	}
	Test(String s) {

		System.out.println("Default constructor");
	}
	public Test (long k) {

		System.out.println("Public constructor ");
	}
	public static void main(String[] args) {
		
		new Test(100);
		new Test(100L);
		new Test("100");
		new Test();
	}
}


Reference and Object 
-------------------------------------------
	Object is the collection of sequence set of bytes. 
	Size of the object in java is 16bytes by default. 
	Out of 16bytes, 12 bytes already used as object header. 
	Block size of the object is always 8 bytes. 

	Test t = new Test ();	//	size of t is 16 bytes by default. 

	static and local memners are not part of java object. 

	Calling the constructor by new keyword , means creating object. 

	Reference is used to reuse the object memory. 

	Test t = new Test (); 

	Here new Test() means object 
	t is the Reference of Test class

	Reference is just like a pointer which always refers to object. 


class Test {

	int a = 10;
	int b = 20;
	int c = 30;

	public static void main(String[] args) {
		
		// Calling by Object name 
		System.out.println(new Test().a);
		System.out.println(new Test().b);
		System.out.println(new Test().c);

		// Calling by reference name 
		Test t = new Test();
		System.out.println(t.a);
		System.out.println(t.b);
		System.out.println(t.c);


	}
}

Object allocates memory for entire class.  static and local members are not part of java object. 

Pass by object 
---------------------------
class Test {

	int a = 10;
	int b = 20;

	static void show(Test t1) {

		t1.a=100;
		t1.b=200;
	}

	public static void main(String[] args) {
		
		Test t = new Test();
		System.out.println(t.a +"\t"+ t.b);  // 10 20 
		show(t); // pass by object 
		System.out.println(t.a +"\t"+ t.b);  // 100 200

	}
}
pass by value 
---------------------
class Test {

	int a = 10;
	int b = 20;

	static void show(int x,int y) {

		x=100;
		y=200;
	}

	public static void main(String[] args) {
		
		Test t = new Test();
		System.out.println(t.a +"\t"+ t.b);  // 10 20 
		show(t.a,t.b); // pass by value 
		System.out.println(t.a +"\t"+ t.b);  // 10 20

	}
}

Object is a collection of sequence set of bytes. 
Base address of the object is known as hashcode. 
Default value of reference is null.

class Test {

	static Test t;

	public static void main(String[] args) {
		
		System.out.println(t); // null

		t = new Test ();
		System.out.println(t); // Test@4b9e255 (hashcode )

		t = new Test ();	
		System.out.println(t); // Test@de3a06f (hashcode )


		t = new Test ();	
		System.out.println(t); // Test@130f889 (hashcode )

		Test t1 = t; // Here t1 refers to the same object 
		System.out.println(t1); // Test@130f889 (hashcode )
	}
}


Copy Constructor
------------------------------------
	If the constructor is used to create a copy of an object then that constructor is known as copy constructor. 

class Student {

	int roll ; 
	String name;

	Student () {

	}
	Student (Student s) { // copy constructor 

		roll = s.roll;
		name = s.name;
	}
	public static void main(String[] args) {
		
		Student s1 = new Student ();
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//0 	null
		s1.roll=101;
		s1.name="Raja";
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//101	Raja

		Student s2 = new Student(s1);
		System.out.println("s2 : "+ s2.roll +"\t"+ s2.name);	
		

	}
}
Copy Constructor
------------------------------------
	If the constructor is used to create a copy of an object then that constructor is known as copy constructor. 

class Student {

	int roll ; 
	String name;

	Student () {

	}
	Student (Student s) { // copy constructor 

		roll = s.roll;
		name = s.name;
	}
	public static void main(String[] args) {
		
		Student s1 = new Student ();
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//0 	null
		s1.roll=101;
		s1.name="Raja";
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//101	Raja

		Student s2 = new Student(s1);
		System.out.println("s2 : "+ s2.roll +"\t"+ s2.name);	
	}
}

private constructor
--------------------------
	If constructor is private , then it is known as private constructor.

Factory Method 
-----------------------------
	If return type of method is a class name ,then it is a Factory method.
	If return type of method is a class name, then it returns an object of that class. 

Singleton class 
---------------------------------------------
	If a class can be instantiated for a single time only, then it is known as Singleton class. 

-----------------------------------------------------------
Example: 

class Test {  // singleton class 

	private static int count=0;
	private Test () {

		System.out.println("Private Constructor ...:) ");
	}
	static Test getObject() {	//	factory method 

		Test t = null;

		if(count == 0) {
			t = new Test ();
		}
		count++;
		return t; 
	}
}
class Demo {

	public static void main(String[] args) {
		
		Test t1 = Test.getObject();
		Test t2 = Test.getObject();
		Test t3 = Test.getObject();

		System.out.println(t1 +"\t"+ t2 +"\t"+ t3);
	}
}

Introduction
Features 
First Program 
Datatypes & Wrapper class 
Opertors 
Variable 
Block 
Method 
Constructor
Control Structure 
-------------------------------------------------------------
It is a very special feature in a programming language , which is generally used to control the flow of program. 

Java support 5 types of  control Structure.
	
	1.	Conditional 

			if 
			if..else 
			nested if 
			multiple if 

	2.	Loop 

			for 
			while 
			do...while 
			for-each 

	3.	selection 
			switch
			case

	4.	Jump 
			break 
			continue 
			return 
			break with label 
			continue with label 

	5.	Sequential :	If no control statement is used in a program, then it is known as Sequential control flows.  Here each & every statement will execute only for a single time. 




Example: 	if 
			if...else 
-------------------------------------------
class Test {

	public static void main(String[] args) {
		
		if(11 % 2 == 0)
			System.out.println("Even Number");
		else 
			System.out.println("Odd Number");
	}
}

Note: ( ? : ) is the replacement of if..else 

Nested if :	If within another if 
------------------------------------
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark < 60 )
			if(mark < 30)
				System.out.println("Fail");
			else
				System.out.println("Avg Mark");
		else 
			System.out.println("First ");
	}
}

Multiple If 
---------------------------------------------
More than one if in a sequence then it is known as multiple if. 
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark >= 60 && mark <= 100)
			System.out.println("First");
		if(mark >= 30 && mark < 60)
			System.out.println("Avg Mark");
		if(mark < 30)
			System.out.println("Fail");
	}
}

Note:	Generally Nested if is faster compare to multiple if.


Loop 
-------------
	When a portion of the java program will be executed for more than one time or repeatedly then loop is a good solution. 

for 
----------------------
	
	It is very suitable lf a programmer already knows 

		the start position 
		the step value 
		the stop position 

	Ex:	Array Traversing 

	for(int i=0 ; i < arr.length ; i++) {

		System.out.println(arr[i]);
	}


while loop 
----------------
	It is very suitable, if the loop runs for a unknown period of times.
	Here the program is itself decide. 

	Example: LinkedList Traversing 

	while(condition) {

		// logic 
	}
do..while loop 
-------------------------
	It is very suitable, if the loop run at least run for a single time. 

	do {

		// Logic 
	}
	while(condition);


	Exampel:	Menu driven program. 

for-each loop
------------------
	It is known as advanced for loop. 
	It is introduced to java to traverse the array & collection easily. 

	Here no initialization part , no condition checking part , no updation part .

	Here we have to specify the source & destination. 

	for( destination : source ) {

		logic 
	}


class Test {

	public static void main(String[] args) {
		
		int arr[] = {11,22,33};

		System.out.println("Traversing Array using for loop ");
		for(int i=0 ; i < arr.length ; i++)
			System.out.println  (arr[i]);

		
		System.out.println("Traversing Array using for-each loop ");
		for(int i : arr)
			System.out.println  (i);




	}
}

switch..case 
---------------------------
	
	It is very suitable for menu programming. 

	case without switch is not allowed but switch without case is allowed. 

	switch(expression) {

		case label : logic 
	}

	switch expression and case label both cannot be float and double. 

	Duplicate case labels are not allowed.





Copy Constructor
------------------------------------
	If the constructor is used to create a copy of an object then that constructor is known as copy constructor. 

class Student {

	int roll ; 
	String name;

	Student () {

	}
	Student (Student s) { // copy constructor 

		roll = s.roll;
		name = s.name;
	}
	public static void main(String[] args) {
		
		Student s1 = new Student ();
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//0 	null
		s1.roll=101;
		s1.name="Raja";
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//101	Raja

		Student s2 = new Student(s1);
		System.out.println("s2 : "+ s2.roll +"\t"+ s2.name);	
	}
}

private constructor
--------------------------
	If constructor is private , then it is known as private constructor.

Factory Method 
-----------------------------
	If return type of method is a class name ,then it is a Factory method.
	If return type of method is a class name, then it returns an object of that class. 

Singleton class 
---------------------------------------------
	If a class can be instantiated for a single time only, then it is known as Singleton class. 

-----------------------------------------------------------
Example: 

class Test {  // singleton class 

	private static int count=0;
	private Test () {

		System.out.println("Private Constructor ...:) ");
	}
	static Test getObject() {	//	factory method 

		Test t = null;

		if(count == 0) {
			t = new Test ();
		}
		count++;
		return t; 
	}
}
class Demo {

	public static void main(String[] args) {
		
		Test t1 = Test.getObject();
		Test t2 = Test.getObject();
		Test t3 = Test.getObject();

		System.out.println(t1 +"\t"+ t2 +"\t"+ t3);
	}
}

Introduction
Features 
First Program 
Datatypes & Wrapper class 
Opertors 
Variable 
Block 
Method 
Constructor
Control Structure 
-------------------------------------------------------------
It is a very special feature in a programming language , which is generally used to control the flow of program. 

Java support 5 types of  control Structure.
	
	1.	Conditional 

			if 
			if..else 
			nested if 
			multiple if 

	2.	Loop 

			for 
			while 
			do...while 
			for-each 

	3.	selection 
			switch
			case

	4.	Jump 
			break 
			continue 
			return 
			break with label 
			continue with label 

	5.	Sequential :	If no control statement is used in a program, then it is known as Sequential control flows.  Here each & every statement will execute only for a single time. 




Example: 	if 
			if...else 
-------------------------------------------
class Test {

	public static void main(String[] args) {
		
		if(11 % 2 == 0)
			System.out.println("Even Number");
		else 
			System.out.println("Odd Number");
	}
}

Note: ( ? : ) is the replacement of if..else 

Nested if :	If within another if 
------------------------------------
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark < 60 )
			if(mark < 30)
				System.out.println("Fail");
			else
				System.out.println("Avg Mark");
		else 
			System.out.println("First ");
	}
}

Multiple If 
---------------------------------------------
More than one if in a sequence then it is known as multiple if. 
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark >= 60 && mark <= 100)
			System.out.println("First");
		if(mark >= 30 && mark < 60)
			System.out.println("Avg Mark");
		if(mark < 30)
			System.out.println("Fail");
	}
}

Note:	Generally Nested if is faster compare to multiple if.


Loop 
-------------
	When a portion of the java program will be executed for more than one time or repeatedly then loop is a good solution. 

for 
----------------------
	
	It is very suitable lf a programmer already knows 

		the start position 
		the step value 
		the stop position 

	Ex:	Array Traversing 

	for(int i=0 ; i < arr.length ; i++) {

		System.out.println(arr[i]);
	}


while loop 
----------------
	It is very suitable, if the loop runs for a unknown period of times.
	Here the program is itself decide. 

	Example: LinkedList Traversing 

	while(condition) {

		// logic 
	}
do..while loop 
-------------------------
	It is very suitable, if the loop run at least run for a single time. 

	do {

		// Logic 
	}
	while(condition);


	Exampel:	Menu driven program. 

for-each loop
------------------
	It is known as advanced for loop. 
	It is introduced to java to traverse the array & collection easily. 

	Here no initialization part , no condition checking part , no updation part .

	Here we have to specify the source & destination. 

	for( destination : source ) {

		logic 
	}


class Test {

	public static void main(String[] args) {
		
		int arr[] = {11,22,33};

		System.out.println("Traversing Array using for loop ");
		for(int i=0 ; i < arr.length ; i++)
			System.out.println  (arr[i]);

		
		System.out.println("Traversing Array using for-each loop ");
		for(int i : arr)
			System.out.println  (i);




	}
}

switch..case 
---------------------------
	
	It is very suitable for menu programming. 

	case without switch is not allowed but switch without case is allowed. 

	switch(expression) {

		case label : logic 
	}

	switch expression and case label both cannot be float and double. 

	Duplicate case labels are not allowed. 

	

class  Test {

	public static void main(String[] args) {
		
		switch(3) {

			case 1 : 	System.out.println("case 1");
						break;

			case 2 : 	System.out.println("case 2");
						break;

			default : System.out.println("No case matched ");
						break;
		}
	}
}
break   continue 
--------------------
	
	break only can be used within switch or loop. 

	break is a control statement which is used to jumps the control to outside of current loop or switch. 

	continue only can be used within  loop. 
	
	continue is a control statement which is used to jumps the control to beginning of current loop.

class  Test {

	public static void main(String[] args) {
		
		for(int i=1 ; i <= 5 ; i++) {

			System.out.println("Hello");
			if(i == 3)
				break;
			System.out.println(i);
		}
		
		System.out.println("----------------------------------");

		for(int i=1 ; i <= 5 ; i++) {

			System.out.println("Hello");
			if(i == 3)
				continue;
			System.out.println(i);
		}
	}
}

break with label  
---------------------------
class  Test {

	public static void main(String[] args) {
		
		a:
		for(int i=1 ; i <= 5 ; i++) {

			b:
			for(int j=1 ; j <= 5 ; j++) {

				c:
				for(int k=1 ; k <= 5 ; k++) {

					System.out.println(k);
					if(k == 3 ) {

						//break; // exit from current loop means k loop 
						//break b;	// exit from b loop means j loop 
						break a;
					}					
				}
			}
		}
	}
}

return 
--------------------
	It is used to return the flow of control to the caller. 

class  Test {

	static void show () {

		int x=2;
		System.out.println("Hello");
		
		if(x==2) {
			//return ; // go to caller 
			System.exit(0); //	stop the execution 
		}
		System.out.println("Hi");
	}
	public static void main(String[] args) {
		
		System.out.println("1");
		show();
		System.out.println("2");
	}
}
break 
break with label 
return 
System.exit 


How to take input from KB 
-----------------------------------------
Following are the ways 
	
	1.	commandline arguments 
	2.	java.util.Scanner class 
	3.	java.io.DataInputStream class 
	4.	java.io.BufferedReader class 
	5.	java.io.Console class 

2.	java.util.Scanner class 
----------------------------------
class Test {

	public static void main(String[] args) {
		
		java.util.Scanner sc = new java.util.Scanner (System.in);

		System.out.println("Enter Your Name");
		String name = sc.nextLine();

		System.out.println("Enter Your Roll");
		int roll = sc.nextInt();

		System.out.println("Enter Your Cgpa");
		double cgpa = sc.nextDouble();

		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Roll : "+roll);
		System.out.println("Cgpa : "+cgpa);


	}
}
D:\5-6>javap java.util.Scanner




class Test {

	public static void main(String[] args)  {
		
		java.io.Console  c = new java.io.Console  ();

		System.out.println("Enter Your Roll");
		int roll = Integer.parseInt(c.readLine());

		System.out.println("Enter Your Name");
		String name = c.readLine();		

		System.out.println("Enter Your Cgpa");
		double cgpa = Double.parseDouble(c.readLine());

		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Roll : "+roll);
		System.out.println("Cgpa : "+cgpa);
	}
}


Relationship between classes 
---------------------------------------------------




Copy Constructor
------------------------------------
	If the constructor is used to create a copy of an object then that constructor is known as copy constructor. 

class Student {

	int roll ; 
	String name;

	Student () {

	}
	Student (Student s) { // copy constructor 

		roll = s.roll;
		name = s.name;
	}
	public static void main(String[] args) {
		
		Student s1 = new Student ();
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//0 	null
		s1.roll=101;
		s1.name="Raja";
		System.out.println("s1 : "+ s1.roll +"\t"+ s1.name);	//101	Raja

		Student s2 = new Student(s1);
		System.out.println("s2 : "+ s2.roll +"\t"+ s2.name);	
	}
}

private constructor
--------------------------
	If constructor is private , then it is known as private constructor.

Factory Method 
-----------------------------
	If return type of method is a class name ,then it is a Factory method.
	If return type of method is a class name, then it returns an object of that class. 

Singleton class 
---------------------------------------------
	If a class can be instantiated for a single time only, then it is known as Singleton class. 

-----------------------------------------------------------
Example: 

class Test {  // singleton class 

	private static int count=0;
	private Test () {

		System.out.println("Private Constructor ...:) ");
	}
	static Test getObject() {	//	factory method 

		Test t = null;

		if(count == 0) {
			t = new Test ();
		}
		count++;
		return t; 
	}
}
class Demo {

	public static void main(String[] args) {
		
		Test t1 = Test.getObject();
		Test t2 = Test.getObject();
		Test t3 = Test.getObject();

		System.out.println(t1 +"\t"+ t2 +"\t"+ t3);
	}
}

Introduction
Features 
First Program 
Datatypes & Wrapper class 
Opertors 
Variable 
Block 
Method 
Constructor
Control Structure 
-------------------------------------------------------------
It is a very special feature in a programming language , which is generally used to control the flow of program. 

Java support 5 types of  control Structure.
	
	1.	Conditional 

			if 
			if..else 
			nested if 
			multiple if 

	2.	Loop 

			for 
			while 
			do...while 
			for-each 

	3.	selection 
			switch
			case

	4.	Jump 
			break 
			continue 
			return 
			break with label 
			continue with label 

	5.	Sequential :	If no control statement is used in a program, then it is known as Sequential control flows.  Here each & every statement will execute only for a single time. 




Example: 	if 
			if...else 
-------------------------------------------
class Test {

	public static void main(String[] args) {
		
		if(11 % 2 == 0)
			System.out.println("Even Number");
		else 
			System.out.println("Odd Number");
	}
}

Note: ( ? : ) is the replacement of if..else 

Nested if :	If within another if 
------------------------------------
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark < 60 )
			if(mark < 30)
				System.out.println("Fail");
			else
				System.out.println("Avg Mark");
		else 
			System.out.println("First ");
	}
}

Multiple If 
---------------------------------------------
More than one if in a sequence then it is known as multiple if. 
class Test {

	public static void main(String[] args) {
		
		int mark=85;
		if(mark >= 60 && mark <= 100)
			System.out.println("First");
		if(mark >= 30 && mark < 60)
			System.out.println("Avg Mark");
		if(mark < 30)
			System.out.println("Fail");
	}
}

Note:	Generally Nested if is faster compare to multiple if.


Loop 
-------------
	When a portion of the java program will be executed for more than one time or repeatedly then loop is a good solution. 

for 
----------------------
	
	It is very suitable lf a programmer already knows 

		the start position 
		the step value 
		the stop position 

	Ex:	Array Traversing 

	for(int i=0 ; i < arr.length ; i++) {

		System.out.println(arr[i]);
	}


while loop 
----------------
	It is very suitable, if the loop runs for a unknown period of times.
	Here the program is itself decide. 

	Example: LinkedList Traversing 

	while(condition) {

		// logic 
	}
do..while loop 
-------------------------
	It is very suitable, if the loop run at least run for a single time. 

	do {

		// Logic 
	}
	while(condition);


	Exampel:	Menu driven program. 

for-each loop
------------------
	It is known as advanced for loop. 
	It is introduced to java to traverse the array & collection easily. 

	Here no initialization part , no condition checking part , no updation part .

	Here we have to specify the source & destination. 

	for( destination : source ) {

		logic 
	}


class Test {

	public static void main(String[] args) {
		
		int arr[] = {11,22,33};

		System.out.println("Traversing Array using for loop ");
		for(int i=0 ; i < arr.length ; i++)
			System.out.println  (arr[i]);

		
		System.out.println("Traversing Array using for-each loop ");
		for(int i : arr)
			System.out.println  (i);




	}
}

switch..case 
---------------------------
	
	It is very suitable for menu programming. 

	case without switch is not allowed but switch without case is allowed. 

	switch(expression) {

		case label : logic 
	}

	switch expression and case label both cannot be float and double. 

	Duplicate case labels are not allowed. 

	

class  Test {

	public static void main(String[] args) {
		
		switch(3) {

			case 1 : 	System.out.println("case 1");
						break;

			case 2 : 	System.out.println("case 2");
						break;

			default : System.out.println("No case matched ");
						break;
		}
	}
}
break   continue 
--------------------
	
	break only can be used within switch or loop. 

	break is a control statement which is used to jumps the control to outside of current loop or switch. 

	continue only can be used within  loop. 
	
	continue is a control statement which is used to jumps the control to beginning of current loop.

class  Test {

	public static void main(String[] args) {
		
		for(int i=1 ; i <= 5 ; i++) {

			System.out.println("Hello");
			if(i == 3)
				break;
			System.out.println(i);
		}
		
		System.out.println("----------------------------------");

		for(int i=1 ; i <= 5 ; i++) {

			System.out.println("Hello");
			if(i == 3)
				continue;
			System.out.println(i);
		}
	}
}

break with label  
---------------------------
class  Test {

	public static void main(String[] args) {
		
		a:
		for(int i=1 ; i <= 5 ; i++) {

			b:
			for(int j=1 ; j <= 5 ; j++) {

				c:
				for(int k=1 ; k <= 5 ; k++) {

					System.out.println(k);
					if(k == 3 ) {

						//break; // exit from current loop means k loop 
						//break b;	// exit from b loop means j loop 
						break a;
					}					
				}
			}
		}
	}
}

return 
--------------------
	It is used to return the flow of control to the caller. 

class  Test {

	static void show () {

		int x=2;
		System.out.println("Hello");
		
		if(x==2) {
			//return ; // go to caller 
			System.exit(0); //	stop the execution 
		}
		System.out.println("Hi");
	}
	public static void main(String[] args) {
		
		System.out.println("1");
		show();
		System.out.println("2");
	}
}
break 
break with label 
return 
System.exit 


How to take input from KB 
-----------------------------------------
Following are the ways 
	
	1.	commandline arguments 
	2.	java.util.Scanner class 
	3.	java.io.DataInputStream class 
	4.	java.io.BufferedReader class 
	5.	java.io.Console class 

2.	java.util.Scanner class 
----------------------------------
class Test {

	public static void main(String[] args) {
		
		java.util.Scanner sc = new java.util.Scanner (System.in);

		System.out.println("Enter Your Name");
		String name = sc.nextLine();

		System.out.println("Enter Your Roll");
		int roll = sc.nextInt();

		System.out.println("Enter Your Cgpa");
		double cgpa = sc.nextDouble();

		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Roll : "+roll);
		System.out.println("Cgpa : "+cgpa);


	}
}
D:\5-6>javap java.util.Scanner


3.	java.io.DataInputStream class 
class Test {

	public static void main(String[] args) throws Exception {
		
		java.io.DataInputStream dis = new java.io.DataInputStream (System.in);

		System.out.println("Enter Your Name");
		String name = dis.readLine();

		System.out.println("Enter Your choice");
		char choice=(char)(dis.read());


		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Choice : "+choice);

	}
}
D:\5-6>javap  java.io.DataInputStream
D:\5-6>javap java.lang.System

4.	java.io.BufferedReader class 
----------------------------------------------
class Test {

	public static void main(String[] args) throws Exception {
		
		java.io.InputStreamReader isr = new java.io.InputStreamReader (System.in);
		java.io.BufferedReader br = new java.io.BufferedReader (isr);

		System.out.println("Enter Your Name");
		String name = br.readLine();

		System.out.println("Enter Your Roll");
		int roll = Integer.parseInt(br.readLine());

		System.out.println("Enter Your Cgpa");
		double cgpa = Double.parseDouble(br.readLine());

		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Roll : "+roll);
		System.out.println("Cgpa : "+cgpa);
	}
}
D:\5-6>javac Test.java

D:\5-6>java Test
Enter Your Name
Raja
Enter Your Roll
123
Enter Your Cgpa
9.1
-----------------------------------------
Name : Raja
Roll : 123
Cgpa : 9.1

D:\5-6>javap java.io.BufferedReader

D:\5-6>javap java.io.Reader

D:\5-6>javap java.io.InputStreamReader

D:\5-6>javap java.lang.System


5.	java.io.Console class 
-------------------------------------------
class Test {

	public static void main(String[] args)  {
		
		java.io.Console  c = System.console();

		System.out.println("Enter Your Roll");
		int roll = Integer.parseInt(c.readLine());

		System.out.println("Enter Your Name");
		String name = c.readLine();		

		System.out.println("Enter Your Cgpa");
		double cgpa = Double.parseDouble(c.readLine());

		System.out.println("-----------------------------------------");
		System.out.println("Name : "+name);
		System.out.println("Roll : "+roll);
		System.out.println("Cgpa : "+cgpa);
	}
}
D:\5-6>javac Test.java

D:\5-6>java Test
Enter Your Roll
1234
Enter Your Name
Raja
Enter Your Cgpa
8.8
-----------------------------------------
Name : Raja
Roll : 1234
Cgpa : 8.8

D:\5-6>




Relationship between classes 
------------------------------------------------------
	
	Relation can be established between two .class file by two ways 

		1.	Association  
		2.	Inheritance 

	Association :	It is non-blood relation.
					Association having a logical relation. 

					No direct/physical relation  between two .class file.
					Here , out of two .class file ,  no one is parent and no one is child class.
					Association support HAS-A relation. 

					Association having two different form 

						1.	Aggregation 
						2.	Composition 

					Aggregation : It is a type of HAS-A relation, where one .class file can exists  or can do function  independently without another class. 

					class Car {

					}
					class MusicPlayer {

					}

					Composition : It is  a type of HAS-A relation, where one .class cannot exist  or cannot do function independently without another .class file. 

					class Car {

					}
					class Engine {

					}


Example: Aggregation and Association
-------------------------------------
class MusicPlayer {

	public void play () {

		System.out.println("Now it is playing .....");
	}
}
class Engine {

	public void getModel() {

		System.out.println("Model No @Honda2021");
	}
}
class Car {

	public static void main(String[] args) {
		
		Engine e = new Engine ();
		e.getModel();

	 	MusicPlayer mp = new MusicPlayer (); 
	 	mp.play();
	}
}


2.	Inheritance 
--------------------------------
	It is an object oriented concept  which is used to create a relation between  two.class file physically. 

Out of two .class file , one must be parent/super/base class and another must be child/sub/derived class. 

	Java provides two keyword to create a relation 

		1.	extends 
		2.	implements

						super-class 			super-interface 
						----------				---------------

	child class 		extends  				implements

	child interface 	not possible 			extends 


Java support Inheritance in five different ways / Types of Inheritance 
-----------------------------------------------------------------------
	
	1.	Single 
	2.	Multi-Level 
	3.	Hierarchical 
	4.	Multiple 
	5.	Hybrid 

Single 
-----------
	In Java, class support single Inheritance by default. 
	In otherwords, each & every class in java  directly or indirectly inherited from Object class. 
	Object is a pre-defined class present in java.lang package. 
	This class is the parent class of each & every class. 

	When only two .class file designed with a relation. 

class Test {

	public static void main(String[] args) {
		
		Test t1 = new Test ();
		Object obj1 = new  Object();

		System.out.println(t1 instanceof Test);
		System.out.println(obj1 instanceof Object);
		System.out.println(t1 instanceof Object);	
		System.out.println(obj1 instanceof Test);
	}
}

Note : 	In the above example, two .class file exists . 
		1.	Object class 
		2.	Test class 

Multi-Level Inheritance
-------------------------
	More than one level is known Multi-level. 
	one .class file behaves like parent class as well as child class. 

class A {

	int x = 100;
	A() {
		System.out.println("A() : Constructor");
	}
}
class B extends A {

	int y = 200;
	B() {
		System.out.println("B() : Constructor");
	}
}
class C extends B {

	int z=300;
	int x = 900;
	C() {
		System.out.println("C() : Constructor");
	}
	public static void main(String[] args) {
		
		C c1 = new C ();
		System.out.println(c1.x);
		System.out.println(c1.y);
		System.out.println(c1.z);
	}
}
D:\5-6>java C
A() : Constructor
B() : Constructor
C() : Constructor
900
200
300

Note:	Object creation always top to bottom 
		Searching member always bottom to top 

Hierarchical Inheritance 
------------------------------------
	When more than one .class file inherited from a single class . 

class A {

}
class B {
	
}

Note: Here A is the Object  and also B is the child of Object. 

Multiple Inheritance
-----------------------------------------
	
	When more than one .class file behaves like parent class.


class A {

}
class B {

}
class C extends A , B {

}
D:\5-6>javac  Test.java
Test.java:7: error: '{' expected
class C extends A , B {
                 ^
1 error

Note: More than one class cannot be extended. 

In Java, Multiple inheritance cannot be achieved with the help of classes.
In Java, Multiple inheritance can    be achieved with the help of interfaces.


Note: 	More than one class cannot be extended. 
		More than one interface can be implemented.





Relationship between classes 
------------------------------------------------------
	
	Relation can be established between two .class file by two ways 

		1.	Association  
		2.	Inheritance 

	Association :	It is non-blood relation.
					Association having a logical relation. 

					No direct/physical relation  between two .class file.
					Here , out of two .class file ,  no one is parent and no one is child class.
					Association support HAS-A relation. 

					Association having two different form 

						1.	Aggregation 
						2.	Composition 

					Aggregation : It is a type of HAS-A relation, where one .class file can exists  or can do function  independently without another class. 

					class Car {

					}
					class MusicPlayer {

					}

					Composition : It is  a type of HAS-A relation, where one .class cannot exist  or cannot do function independently without another .class file. 

					class Car {

					}
					class Engine {

					}


Example: Aggregation and Association
-------------------------------------
class MusicPlayer {

	public void play () {

		System.out.println("Now it is playing .....");
	}
}
class Engine {

	public void getModel() {

		System.out.println("Model No @Honda2021");
	}
}
class Car {

	public static void main(String[] args) {
		
		Engine e = new Engine ();
		e.getModel();

	 	MusicPlayer mp = new MusicPlayer (); 
	 	mp.play();
	}
}


2.	Inheritance 
--------------------------------
	It is an object oriented concept  which is used to create a relation between  two.class file physically. 

Out of two .class file , one must be parent/super/base class and another must be child/sub/derived class. 

	Java provides two keyword to create a relation 

		1.	extends 
		2.	implements

						super-class 			super-interface 
						----------				---------------

	child class 		extends  				implements

	child interface 	not possible 			extends 


Java support Inheritance in five different ways / Types of Inheritance 
-----------------------------------------------------------------------
	
	1.	Single 
	2.	Multi-Level 
	3.	Hierarchical 
	4.	Multiple 
	5.	Hybrid 

Single 
-----------
	In Java, class support single Inheritance by default. 
	In otherwords, each & every class in java  directly or indirectly inherited from Object class. 
	Object is a pre-defined class present in java.lang package. 
	This class is the parent class of each & every class. 

	When only two .class file designed with a relation. 

class Test {

	public static void main(String[] args) {
		
		Test t1 = new Test ();
		Object obj1 = new  Object();

		System.out.println(t1 instanceof Test);
		System.out.println(obj1 instanceof Object);
		System.out.println(t1 instanceof Object);	
		System.out.println(obj1 instanceof Test);
	}
}

Note : 	In the above example, two .class file exists . 
		1.	Object class 
		2.	Test class 

Multi-Level Inheritance
-------------------------
	More than one level is known Multi-level. 
	one .class file behaves like parent class as well as child class. 

class A {

	int x = 100;
	A() {
		System.out.println("A() : Constructor");
	}
}
class B extends A {

	int y = 200;
	B() {
		System.out.println("B() : Constructor");
	}
}
class C extends B {

	int z=300;
	int x = 900;
	C() {
		System.out.println("C() : Constructor");
	}
	public static void main(String[] args) {
		
		C c1 = new C ();
		System.out.println(c1.x);
		System.out.println(c1.y);
		System.out.println(c1.z);
	}
}
D:\5-6>java C
A() : Constructor
B() : Constructor
C() : Constructor
900
200
300

Note:	Object creation always top to bottom 
		Searching member always bottom to top 

Hierarchical Inheritance 
------------------------------------
	When more than one .class file inherited from a single class . 

class A {

}
class B {
	
}

Note: Here A is the Object  and also B is the child of Object. 

Multiple Inheritance
-----------------------------------------
	
	When more than one .class file behaves like parent class.


class A {

}
class B {

}
class C extends A , B {

}
D:\5-6>javac  Test.java
Test.java:7: error: '{' expected
class C extends A , B {
                 ^
1 error

Note: More than one class cannot be extended. 

In Java, Multiple inheritance cannot be achieved with the help of classes.
In Java, Multiple inheritance can    be achieved with the help of interfaces.


Note: 	More than one class cannot be extended. 
		More than one interface can be implemented. 

Example: Interface 
----------------------
interface A {

}
interface B {

}
class C implements A , B {

	public static void main(String[] args) {
		
		System.out.println("Example of Interface ");
	}
}
D:\5-6>javac Test.java

D:\5-6>java C
Example of Interface

Interface 
----------------
	It is similar to abstract class i.e. object cannot be created directly in case of abstract class as well as in interface. 


	abstract class vs interface
	-----------------------------------
	1.	Variable	:	Any type of Variable can be declared within abstract class whereas by default Variable within interface  is public , static and final.

	2.	Method 		:	Any type of method can be designed within abstract class whereas method within interface by default public and abstract.

	3.	Constructor :	 Constructor is allowed within abstract class whereas it is not allowed within interface.

Example: 
---------------
interface Test {

	int x = 10;
	void show();
}
D:\5-6>javap Test
Compiled from "Test.java"
interface Test {
  public static final int x;
  public abstract void show();
}

Example: interface 
---------------------------------------
interface Test {

	int x = 10;
	void show();
}
abstract class Demo  implements Test {

	int y=20;

	void display() {
		System.out.println("display() : abstract class");
	}
	abstract void fun1();

	Demo () {

		System.out.println("Constructor : Abstract class ");
	}
}
class MyClass extends Demo {

	void fun1() {

		System.out.println("fun1() : Demo");
	}
	public void show() {
		System.out.println("show() : Test");
	}
	MyClass () {
		System.out.println("Constructor : MyClass");
	}
	public static void main(String[] args) {
		
		MyClass mc = new MyClass ();
		System.out.println(Test.x);
		System.out.println(mc.y);
		mc.show();
		mc.display();
		mc.fun1();

	}
}

Note: 	interface is used to create a prototype of class.  
		In otherwords, it is a blue-print of class. 


Multiple inheritance cannot be achieved with the abstract classes as it may creates method ambiguity. 

Multiple inheritance can be achieved with the interfaces as it doesnot create method ambiguity. 

Example: Multiple inheritance cannot be achieved with the abstract classes as it may creates method ambiguity. 
----------------------------------------------------------------------
class A {

	void show() {

	}
}
class B {

	void show() {
		
	}
}
class Test extends A , B {

	public static void main(String[] args) {
		
		Test t = new Test ();
		t . show();
	}
}

Example: Multiple inheritance can be achieved with the interfaces as it doesnot create method ambiguity. 

Example: Multiple inheritance
---------------------------------------------
interface  A {

	void show();
}
interface B {

	void show();
}
class Test implements A , B {

	public void show() {
	
		System.out.println("show() : Test class ");
	}

	public static void main(String[] args) {
		
		Test t = new Test ();
		t . show();
	}
}
D:\5-6>javac Test.java

D:\5-6>java Test
show() : Test class

Generally interface contains abstract method i.e. method declaration only ,  but in latest version , we can design method within interface but it should be static/private/default. 

static method can be designed within interface , but cannot be called by child class object due to ambiguity issues i.e. only can be called by class name.

static method can be designed within interface , but cannot be called by child class object due to ambiguity issues i.e. only can be called by class name. 


// static method can be designed within interface , but cannot be called by child class object due to ambiguity issues i.e. only can be called by class name. 

interface A {

	static void show() {

		System.out.println("show() method within A interface  ");
	}
}

interface B {

	static void show() {

		System.out.println("show() method within B interface  ");
	}
}
class Test implements A, B {

	public static void main(String[] args) {
		
		Test t = new Test();
		A.show();
		B.show();
	}
}
D:\5-6>javac Test.java

D:\5-6>java Test
show() method within A interface
show() method within B interface


Hybrid Inheritance 
----------------------
	Combination of more than one type of Inheritance is hybrid. 

class A {

}
class B {

}
class C extends A {

}

Polymorphism 
-----------------
		It is an object oriented concept which is used to create a different form of a single resource.



	How to achive Polymorphism?
	--------------------------------
		It can be achived by two ways 
			1.	Compile-time i.e. overloading 
			2.	Run-time Polymorphism i.e. overriding 


	Compile-time Polymorphism
	-------------------------------------------
			Here Compiler decide the calling resource .
			Compile-time Polymorphism is also known as static binding.

			Overloading are two types in Java 

				1.	Method overloading
				2.	Constructor overloading

1.	Method overloading
--------------------------
	
		Following are the four rules required to be satisfied 

			1.	More than one method 
			2.	Name must be same 
			3.	Within a single class 
			4.	Argument must be different 


	Example: method overloading
	-----------------------------
	class Test {

	static void add(int a , int b) {
		System.out.println(a+b);
	}
	static void add(float a , float b ) {
		System.out.println(a+b);
	}
	void add (int a , int b , int c) {
		System.out.println(a+b+c);
	}
	public static void main(String[] args) {
		
		Test t = new Test ();

		t.add(11,22);
		t.add(12,13,14);
		t.add(12.0f , 23.9f);
	}

}

2.	Constructor overloading
-------------------------------------------------
		If more than one Constructor designed within a single class with different arguments known as constructor overloading. 

class Test {

	Test() {

		System.out.println("Test() : Constructor without args");
	}
	Test (int x) {

		System.out.println("Test() with int args ");
	}
	Test(String s) {

		System.out.println("Test() with String args");
	}
	public static void main(String[] args) {
		
		new Test();
		new Test(123);
		new Test("Hello");
	}

}
D:\5-6>javac Test.java

D:\5-6>java Test
Test() : Constructor without args
Test() with int args
Test() with String args


Working with "this" keyword 
---------------------------------
	"this" is a keyword in Java , which always refer to current class object.

	"this" is not responsible to create a new object, it only refers.

	"new" keyword is responsible to create a new object.

	"this" only can be used within non-static context i.e. non-static method / block / Constructor.

	static is not a part of java object.

Uses of "this" keyword 
--------------------------------
	 1.	"this" keyword is used to display the current object hashcode.
	 2.	"this" keyword can be used as a return value.
	 3.	When the local and instance variable is same , then "this" keyword refer to instance variable.
	 4.	"this" keyowrd can be passed as a function argument
	 5.	"this" keyword can be passed as a constructor argument
	 
	 6.	"this" keyword can be used to call the constructor of current class without allocates new memory.

 1.	"this" keyword is used to display the current object hashcode.
 ---------------------------------------------------------------------------
 class Test {

	void show() {

		System.out.println(this);
	}
	public static void main(String[] args) {
		
		Test t = new Test ();
		System.out.println(t);

		t.show();
	}

}

 2.	"this" keyword can be used as a return value.
 --------------------------------------------------------
 class Test {

	Test show() {

		return this;
	}
	public static void main(String[] args) {
		
		Test t = new Test ();
		System.out.println(t.show());
	}

}
3.	When the local and instance variable is same , then "this" keyword refer to instance variable.
-----------------------------------------------------------
class Test {

	int x = 100; // instance 
	void show() {

		int x = 200; // Local 
		System.out.println(x);
		System.out.println(this.x);

	}
	public static void main(String[] args) {
		
		Test t = new Test ();
		t.show();
	}

}


4.	"this" keyowrd can be passed as a function argument
5.	"this" keyword can be passed as a constructor argument
---------------------------------------------------------

class Demo {

	int x = 100;
	void display (Test t) {

		int x = 200;
		System.out.println(x);
		System.out.println(this.x);
		System.out.println(t.x);
	}
}

class Test {

	int x = 300;
	void show() {

		new Demo().display(this);
	}
	public static void main(String[] args) {
		
		new Test() . show();

	}
}

6.	"this" keyword can be used to call the constructor of current class without allocates new memory.
----------------------------------------------------------

class Test {

	Test() {

		System.out.println("Test() : Constructor without args");
	}
	Test (int x) {

		this();
		System.out.println("Test() with int args ");
	}
	Test(String s) {

		this(123);
		System.out.println("Test() with String args");
	}
	public static void main(String[] args) {
		
		new Test("Hello");
	}

}

Note:  call to this must be first statement in constructor



Method Overriding 
----------------------------
	When the signature (Function_Name , Function_Argument, Function_Return_Type) of sub-class method is same with the signature of super-class method then it is known as method Overriding.

	Why to Learn ?
		When the developer of the child class is satisfied with the signature of super-class method but not satisfied with the contents/logic, at that time , child class developer take the signature of super-class method and design according to requirement i.e. technically known as method overriding.


	When overriding is not possible ?
		If the method is final.	


Example: Method Overriding 
----------------------------------------------------
class  Vehicle {

	void run () {

		System.out.println("Vehicle is Running safely with the speed 50");
	}
}
class Cycle extends Vehicle {

	void run () {

		System.out.println("Cycle is Running safely with the speed 10");
	}
	public static void main(String[] args) {
		
		Cycle c = new Cycle ();
		c.run();
	}

}

Example: Overriding with abstraction 
-----------------------------------------------------

abstract class Animal {

	abstract public void doSound();

	public void doSleep() {

		System.out.println("Animal is sleeping ,dont distrub..:) ");
	}
}

class Dog extends Animal {

	public void doSound() {

		System.out.println("Dog sound Vo Vo ");
	}	
}

class Cat extends Animal {

	public void doSound() {

		System.out.println("Cat sound Meawn Meawn ");
	}	
	public void doSleep() {

		System.out.println("Cat is sleeping ");
	}
}
class Cow extends Animal {

	public void doSound() {

		System.out.println("Cow sound Maa Maaa ");
	}	
}
class Test {

	public static void main(String[] args) {
		
		Dog dog = new Dog ();
		dog.doSound();
		dog.doSleep();

		Cat cat = new Cat();
		cat.doSound();
		cat.doSleep();
		
		Cow cow = new Cow();
		cow.doSound();
		cow.doSleep();
		
	}
}

Restrictions 
--------------------
	1.	Final cannot override 
	2.	Static method cannot override with static implementation. 

	class Test {

		static  void show () {

		}
	}
	class Demo extends Test {

		static void show () {

		}
	}

	3.	Access Specifier of the child class method should be same or less restricted. 

			public 
			protected 
			default 
			private 



Working with "super" keyword 
----------------------------------------

Like this "super" is a keyword in Java.
"this" keyword refers to current class object but "super" keyword refers to parennt class object.

Both "super" and "this" cannot be used within static context.

Uses of super keyword
--------------------------------
	1.	To call the constructor of parent class from the constructor of sub-class , "super" keyword can be used.
	2.	When the variable of the child class and parent class is same , then "super" always refer to parent class variable.
	3.	When the method of the child class and parent class is same , then "super" always refer to parent class method.



Each and every constructor 1st statement is "super"  keyword i.e. super();

// 1.	To call the constructor of parent class from the constructor of sub-class , "super" keyword can be used.

class Test {

	Test (int x) {

		System.out.println("Test() : Constructor ");
	}
}
class Demo extends Test {

	Demo() {

		super(123);	
		System.out.println("Demo() : Constructor");
	}
	public static void main(String[] args) {
		
		new Demo();
	}
}

2.	When the variable of the child class and parent class is same , then "super" always refer to parent class variable.

3.	When the method of the child class and parent class is same , then "super" always refer to parent class method.

class Test {

	int x = 100;

	void display() {

		System.out.println("display() : Test");
	}
}
class Demo extends Test {

	int x = 200;

	void display() {

		System.out.println("display() : Demo");
	}

	void show() {

		int x = 300;
		System.out.println(x);
		System.out.println(this.x);
		System.out.println(super.x);

		display();
		super.display();
	}
	public static void main(String[] args) {
		
		new Demo().show();
	}
}

Dynamic Method dispatching 
-----------------------------
	It is known as dynamic binding.
	Dynamic method dispatching possible by two ways 

		1.	Up-casting 
		2.	Down-casting 

Up-casting
	----------------
		When the super class reference refer to child class object , then it is known as Up-casting


Down-casting
	----------------
		When the sub class reference refer to super class object , then it is known as Down-casting

class Test {

}
class Demo extends Test {

	public static void main(String[] args) {
		
		Test t =  new Demo(); // Up-casting

		Demo d = (Demo)  new Test (); // Down-casting
	}
}




Dynamic Method dispatching 
-----------------------------
	It is known as dynamic binding.
	Dynamic method dispatching possible by two ways 

		1.	Up-casting 
		2.	Down-casting 

Up-casting
	----------------
		When the super class reference refer to child class object , then it is known as Up-casting


Down-casting
	----------------
		When the sub class reference refer to super class object , then it is known as Down-casting

class Test {

}
class Demo extends Test {

	public static void main(String[] args) {
		
		Test t =  new Demo(); // Up-casting

		Demo d = (Demo)  new Test (); // Down-casting
	}
}


Example:  Up-casting 
--------------------------

class Test {

	void fun1() {
		System.out.println("fun1() within Test.class");
	}
	void fun2() {
		System.out.println("fun2() within Test.class");
	}
}
class Demo extends Test {

	void fun1() {
		System.out.println("fun1() within Demo.class");
	}
	void fun3() {
		System.out.println("fun3() within Demo.class");
	}
	public static void main(String[] args) {
		
		Test t = new Demo ();	//	up-casting 
		t.fun1(); // Reference t always check the method existence within Test class at compile-time , as t refers to the object of Demo class, it executes within Demo class , if method is not available/designed within Demo.class then it goes to its parent class i.e. Test.class. 

		t.fun2();
		//t.fun3(); // error as it is not designed within Test class 
	}
}

Example: Down-casting
------------------------------------

Object Cloning :	It is a  technique to create a clone/copy of an object. 

clone()	:	It is a method of Object class which is responsible to create a clone of an object. 

Object to be cloned , coresponding class should be the sub-class of Cloneable interface. 

Cloneable is a marker interface in Java. 

interface without any members is known as marker interface. 
interface with a single method  is known as functional interface. 

Marker interface indicates to JVM, this object is created for a very special purpose.

class Student  implements Cloneable{

	int roll ; 
	String name ; 

	public static void main(String[] args) throws Exception {
		
		Student s1 = new Student ();
		System.out.println(s1.roll +"\t"+ s1.name);
		s1.roll=100;
		s1.name="Raja";
		System.out.println(s1.roll +"\t"+ s1.name);
	
		// Student s2 = s1;	 // It means , single object is pointed by s2 and s1 
		Student s2 = (Student) s1.clone(); // Here one new object will be created and contents of old object will be copied. // down-casting

		System.out.println(s2.roll +"\t"+ s2.name);

	}
}

Package in Java 
------------------------------
	Package is a container. 
	It is a collection of .class files and sub-packages.
	Package looks like a folder in Java, all the folders are not packages. 

	Generally package  is used to solve following probelms 

			1.	Avoid class name ambiguity
			2.	Searching a .class file very faster 
			3.	Support Encapsulation



	Java support two types of package 
		1.	Pre-defined package 
		2.	User-defined package 

	Pre-defined packages 
	-----------------------
		The package which already in-built with the standard JDK i.e.  pre-defined pacakge.
		In otherwords, it is provided by Sun/Oracle company.
		Package is a container.



		Main-Package 
			|
			|	---->	Sub-Package
							|
							|	--->	.class file 
							|	--->	.class file 
							|
							|	--->	Sub-Package
											|
											|	--->	.class file 
											|	--->	.class file 	
											|	
											|	--->	Sub-Package
															|
															|	--->	.class file 
															|	--->	.class file 		

Example : 	java.lang 
			java.util 
			java.sql 
			java.net 
			java.awt 
			javax.swing 
			java.io 
			java.rmi 
			java.awt.event
			java.util.zip 


User-defined package 
		---------------------------
			The package which is developed by developer to fulfill the requirement of project i.e. User-defined package.
			"package" is a keyword in Java, which is used to create a package.

Example: How to create User-defined package
-------------------------------------------
package p1.p2.p3;
class Test {

	public static void main(String[] args) {
		
		System.out.println("Welcome to package world ....:) ");
	}
}

D:\5-6>javac     -d    G:/     Test.java 		//	 Package will be created in G:/ drive

D:\5-6>java  p1.p2.p3.Test			//	Error as package location is different 

Error: Could not find or load main class p1.p2.p3.Test

D:\5-6>g: 		//	switch to G driver

G:\>java  p1.p2.p3.Test
Welcome to package world 


Note:	
			-d <directory>              Specify where to place generated class files

													p1
														|->	p2
															  |-> p3		
															  		|->	Test.class


													 
			G:/ 						Specify where to place generated main package 

													G:/
													 |--->	p1 


To execute the .class file present in a package, we bound to present in that location where main package is available, now main package is available in G:/ drive. 



To execute from any location , it is required to set the classpath. We can set classpath by two different ways 
		
		1.	Temporary period 
		2.	Permanently 


How to set the classpath for a Temporary period 
----------------------------------------------------
	
D:\5-6>java  p1.p2.p3.Test
Error: Could not find or load main class p1.p2.p3.Test
Caused by: java.lang.ClassNotFoundException: p1.p2.p3.Test

D:\5-6>set classpath=;G:/;

D:\5-6>java  p1.p2.p3.Test
Welcome to package world ....:)

D:\5-6>c:

C:\Users\Mother>java  p1.p2.p3.Test
Welcome to package world ....:)

C:\Users\Mother>g:

G:\>java  p1.p2.p3.Test
Welcome to package world ....:)

How to set the classpath Permanently
--------------------------------------
My Computer 
	|
	|	
	|->	Right Click 
			|	
			|->	Properties
					|	
					|->	Advanced System Settings 
							|
							|->	Enviorment Variables
										|
										|->	Unser / System Variable 
												|
												|->	Click On New Button
														|
														|->	Variable Name  :	classpath
														|
														|->	Variable Value :	;G:/;

																	|
																	|->	OK(3) 

Note: Open cmd then execute 

Path vs classpath
----------------------------

	Path variable is used to set the path of executable file (.exe) whereas classpath is used to set the path of class file / jar file (.class/.jar).


	Path is an enviorment variable which is used by operating system to find the .exe file whereas classpat is an enviorment variable which is used by javac compiler to find the path.


Access specifier in Java 
-------------------------------------------------------
public 
protected 
default
private





Members of a .class file  (if present in package)  can be accessed by two ways 
	
	1.	Fully qualified name 
	2.	by import statement 

1.	Fully qualified name 
----------------------------
Specifying the full path of package each & every time is known as fully qualified name.

			Ex:	java.util.Scanner sc = new java.util.Scanner (System.in);
				java.io.BufferedReader 


import statement 
-------------------------
	
	import is a keyword in Java , which is used to check the class/package existence.


	single class importing
	------------------------
		import java.util.Scanner ;		//	Now Scanner can be accessed directly without writting java.util. again and again.
	

	package importing 
	----------------------
	import java.util.* ;			//	Here * means all the .class file of util package. Now All the .class files of util package can be accessed directly without writting java.util. again and again.


Note:	Geneally import is better than Fully qualified name , but in case of class name ambiguity , fully qualified name is must required. 

import java.util.Scanner; 
import java.util.*; 
import java.sql.*; 

class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		//Date d = new Date ();//reference to Date is ambiguous

		java.util.Date d = new java.util.Date (); // Fully qualified name is mandotory
		System.out.println(d);
	}
}


Array 
-------------------------
	Array is a collection of similar types of data.
	It is used to create a List i.e. List of roll number , list of name ,...etc.
	Array store data in sequential order i.e. memory allocation in a sequence.

	List can be prepared by two different ways 

		1.	Array 
		2.	LinkedList 

	

	-> Array is static in nature but LinkedList is dynamic.

		static means cannot change the size at the time of execution.
		dynamic means , size can be changed.

	-> Both Array and LinkedList store similar types of data. If list size is known to a programmer then better to choose Array , for unknown size list better to choose LinkedList.


	->	 Array is puerly sequential whereas linkedlist is not sequential.

Types of Array
---------------------------------------
	
	1.	One-dimensional array 
	2.	Multi-dimensional array 


Example: 1D 
--------------------
import  java.util.*;
class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		System.out.println("Enter the size");
		int size = sc.nextInt();

		int arr[] = new int[size];

		System.out.println("Enter array elements");
		for(int i=0 ; i < arr.length ; i++) {

			arr[i] = sc.nextInt();
		}

		System.out.println("Array is ");
		for(int i=0 ; i < arr.length ; i++) {

			System.out.print (arr[i] +"\t");
		}
	}
}

1D using function 
------------------------
import  java.util.*;
class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		System.out.println("Enter the size");
		int size = sc.nextInt();

		int arr[] = new int[size];

		input(arr);
		display(arr);
	}
	static void  input(int arr[]) {
		
		Scanner sc = new Scanner (System.in);
		System.out.println("Enter array elements");
		for(int i=0 ; i < arr.length ; i++) {

			arr[i] = sc.nextInt();
		}
	}
	static void  display(int arr[]) {
			
		System.out.println("Enter array elements");
		for(int i=0 ; i < arr.length ; i++) {

			System.out.print  (arr[i] +"\t");
		}
		System.out.println();
	}
}

Arrays class 
-------------------
	It is a pre-defined class present in java.util package. 
	It is used to manipulate array such as sorting / searching etc. 

import  java.util.*;
class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		System.out.println("Enter the size");
		int size = sc.nextInt();

		int arr[] = new int[size];

		input(arr);
		display(arr);

		Arrays.sort(arr);	//	sort the array 
		display(arr);
		System.out.println(Arrays.toString(arr));  // display array in a String format

		int index = Arrays.binarySearch(arr,22); // Search 22 from array 
		if(index >= 0 )
			System.out.println("Found at "+index);
		else
			System.out.println("Not found");

		int brr[] = Arrays.copyOfRange(arr,0,4); // Copy the array 
		System.out.println(Arrays.toString(brr));  // display array in a String format

		System.out.println(Arrays.equals(arr,brr)); // Check two array contents

		System.out.println("Display in reverse order ");
		for(int i=arr.length-1 ; i >= 0 ; i--)
			System.out.println(arr[i]);
	}
	static void  input(int arr[]) {
		
		Scanner sc = new Scanner (System.in);
		System.out.println("Enter array elements");
		for(int i=0 ; i < arr.length ; i++) {

			arr[i] = sc.nextInt();
		}
	}
	static void  display(int arr[]) {
			
		System.out.println("Array is ");
		for(int i=0 ; i < arr.length ; i++) {

			System.out.print  (arr[i] +"\t");
		}
		System.out.println();
	}
}

2D 
---------------------
	It is known as matrix. 

	2D is the collection of 1D. 


import  java.util.*;
class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		System.out.println("Enter the row & col");
		int row = sc.nextInt();
		int col = sc.nextInt();

		int arr[][] = new int[row][col];

		input(arr,row,col);
		display(arr,row,col);

	}
	static void  input(int arr[][], int row , int col) {
		
		Scanner sc = new Scanner (System.in);
		
		for(int i=0 ; i < row ; i++) {

			System.out.println("Enter array elements for row "+i);
			for(int j=0 ; j < col ; j++) {

				arr[i][j] = sc.nextInt();
			}
		}
	}
	static void  display(int arr[][] , int row , int col) {
			
		System.out.println("Array is ");
		for(int i=0 ; i < row  ; i++) {

			for(int j=0 ; j < col ; j++) {

				System.out.print  (arr[i][j] +"\t");
			}
			System.out.println();
		}
		
	}
}







2D 
---------------------
	It is known as matrix. 

	2D is the collection of 1D. 


import  java.util.*;
class Test {

	public static void main(String[] args) {
		
		Scanner sc = new Scanner (System.in);

		System.out.println("Enter the row & col");
		int row = sc.nextInt();
		int col = sc.nextInt();

		int arr[][] = new int[row][col];

		input(arr,row,col);
		display(arr,row,col);

	}
	static void  input(int arr[][], int row , int col) {
		
		Scanner sc = new Scanner (System.in);
		
		for(int i=0 ; i < row ; i++) {

			System.out.println("Enter array elements for row "+i);
			for(int j=0 ; j < col ; j++) {

				arr[i][j] = sc.nextInt();
			}
		}
	}
	static void  display(int arr[][] , int row , int col) {
			
		System.out.println("Array is ");
		for(int i=0 ; i < row  ; i++) {

			for(int j=0 ; j < col ; j++) {

				System.out.print  (arr[i][j] +"\t");
			}
			System.out.println();
		}
		
	}
}

3D 
-------------------------------
	
public class Test {
	
	public static void main(String[] args) {
		
		char arr[][][] = new char [2][3][2];
		
		char ch = 'A';
		for(int i=0 ; i < 2 ; i++) {
			
			for(int j=0 ; j < 3 ; j++ ) {
				
				for (int k=0 ; k < 2 ; k++) {
					
					arr[i][j][k] = ch++;
					System.out.print (arr[i][j][k] +"\t");
				}
				System.out.println();
			}
			System.out.println();
		}		
	}
}


Example: length 
--------------------

public class Test {
	
	public static void main(String[] args) {
		
		char arr[][][] = new char [2][3][2];
		
		System.out.println(arr.length);	
		System.out.println(arr[0].length);
		System.out.println(arr[0][0].length);
	}
}

String in Java 
--------------------------------------
	Set of characters enclosed within double quote ("") i.e. String.
	Example:  "Java" 

	In Java, String cannot be treated as character array & vice-versa.

	In C/C++, character array ended with '/0' or null character then it is treated as String.


	In Java, String is a pre-defined class present in java.lang package.

	String class is used to create and manipulate the String.

	String can be constructed by two different ways 

		1.	By using Literal 
				String s1 = "Hello";
		2.	By new keyword 
				String s3 = new String ("Hello");
	Note:	

		If String is created by Literal , then it allocates memory in String pool.
		String pool cannot store duplicate String.
		String pool is a temporary memory.

		"new" keyword always allocates memory from a different location.
		
		"==" symbol always check the contents in Java, but in case String it checks the hashcode.

		equals() :	 It is a pre-defined method of String class , which is used to check the contents.


Example: == vs equals() method 


public class Test {
	
	public static void main(String[] args) {
		
		
		String s1 = "Hello"; // by Literal 
		String s2 = "Hello";
		String s3 = new String("Hello"); // by new 
		String s4 = new String("Hello");
		
		System.out.println(s1 +"\t"+ s2 +"\t"+ s3 +"\t"+ s4);
		
		System.out.println(s1 == s2);
		System.out.println(s2 == s3);
		System.out.println(s3 == s4);
		
		System.out.println(s1.equals(s2));
		System.out.println(s2.equals(s3));
		System.out.println(s3.equals(s4));
	}
}

String is immutable i.e. contents of String cannot be changed.

public class Test {
	
	public static void main(String[] args) {
		
		String s1 = new String("Hello");
		
		System.out.println(s1);
		System.out.println(s1.concat(" Welcome")); // Merge two String
		System.out.println(s1);
		s1 ="Java"; // Here re-assigned 
		System.out.println(s1);
	}
}


Methods of String 
------------------------

public class Test {
	
	public static void main(String[] args) {
		
		String s1 = new String("Hello");
		
		System.out.println(s1.toUpperCase());
		System.out.println(s1);
		
		System.out.println(s1.toLowerCase());
		System.out.println(s1.charAt(0));	//	 character at specified index
		System.out.println(s1.replace('l', 'L'));	//	replace old character with new character
		
		s1="Hello";
		System.out.println(s1.equals("Hello"));
		System.out.println(s1.equals("hello"));
		System.out.println(s1.equalsIgnoreCase("Hello"));
		System.out.println(s1.equalsIgnoreCase("hello"));
				
	}
}



Note:	equals() method check the contents & it is case sensitive.
		equalsIgnoreCase() method check the contents & it is case not sensitive.


Methods of String 
-------------------------
import java.util.Arrays;

public class Test {
	
	public static void main(String[] args) {
		
		String s1 = new String("Hello");
		System.out.println(s1);
		System.out.println(s1.codePointAt(0));// ASCII value of the specified index
		
		char arr[] = s1.toCharArray();	//	 Convert a String to character to array
		System.out.println(Arrays.toString(arr));
		arr[0]='K';
		s1 = new String (arr);	//	 Convert character array to String
		System.out.println(s1);
		
		
		String s2 = new String ("Java is Simple It is a language It is OO");
		System.out.println(s2);
		String s3[] =  s2.split(" ");	//	 It divides the Original String to multiple Sting based on a specified String  
		System.out.println(Arrays.toString(s3));
				
	}
}


StringBuffer & StringBuilder  
======================================
	
	String is a pre-defined final class.
	StringBuffer is a  pre-defined final class.
	StringBuilder is a pre-defined final class.

	All the above three classes are  present in java.lang package. 

	String is immutable whereas StringBuffer and StringBuilder is mutable.
	StringBuffer is synchronized whereas StringBuilder is not synchronized .
	String is synchronized.


	synchronized String means , it supports locking.
	Locking :	 Only one thread can access that String at a single time.

	immutable vs mutable
	-------------------------

	public class Test {
	
	public static void main(String[] args) {
		
		String s1 = new String("hello");
		System.out.println(s1);
		System.out.println(s1.concat(" Hi"));
		System.out.println(s1);
		
		System.out.println("----------------------");
		
		
		StringBuffer sb1 = new StringBuffer("hello");
		System.out.println(sb1);
		System.out.println(sb1.append(" Hi"));
		System.out.println(sb1);
		
		System.out.println("----------------------");
		
		StringBuilder sb2 = new StringBuilder("hello");
		System.out.println(sb2);
		System.out.println(sb2.append(" Hi"));
		System.out.println(sb2);
	}
}






Example: Methods of StringBuffer
---------------------------------------------------
class Test {

	public static void main(String[] args) {
		
		StringBuffer sb1 = new StringBuffer("Hello");
		System.out.println(sb1.insert(0, "Ok "));
		System.out.println(sb1.delete(0, 3)); /*It means 0-3 index */
		System.out.println(sb1.replace(0, 3, "Java")); /*It means 0-2 index */
		
		System.out.println(sb1.hashCode());
		System.out.println(sb1.substring(0,4)); /*It means 0-3 index */
		System.out.println(sb1.charAt(0));
	
	}
}

Note:	All the methods of StringBuffer available in StringBuilder.


Example: Converting String to StringBuffer and vice-versa 

class Test {

	public static void main(String[] args) {
		
		
		String s1 = new String("Hello");
		
		System.out.println(s1);
		StringBuffer sb1 = new StringBuffer(s1);// Converting a String to StringBuffer
		sb1.reverse(); /reverse() is not available in String/
		System.out.println(sb1);
		
		String s2 = new String(sb1);// Converting a  StringBuffer to String
		if(s1.equals(s2)) /equals() method is not available in StringBuffer/
			System.out.println("Yes Palindrome");
		else
			System.out.println("Not Palindrome");
	
	}
}


Collection Framework in Java / Data Structure using Java language 
------------------------------------------------------------------
	Collection Framework provides a readymade architecture to store and manipuate group of objects.

	
	Collection  :	It is a group of similar type of objects.
					Example:	Collection of student objects 
								Collection of integer objects
								.............................
	
	Framework	:	It provides an architecture i.e. provides pre-defined libraries.

	Collection Framework provides set of classes & interfaces to store and manipulate group of objects.

	Collection Framework introduced in JDK 1.2.

	Collection is itself a pre-defined interface present in java.util package.

	It is the root interface of all the classes and interfaces related to Collection Framework.



LinkedList 
---------------------------------
	Linkedlist is a pre-defined class present in java.util package.
	This class is used to create and manupulate the double linkedlist.

	LinkedList can be created by two ways 

		1.	By Manually  like C/C++
		2.	By using Collection Framework

Example: LinkedList Manually
---------------------------------
class Employee {

	int eid ;
	String name;
	double salary;
	Employee next; /next is the reference of Employee class which will store object in future/
}
class Test {

	public static void main(String[] args) {
		
		Employee e1 = new Employee();
		Employee e2 = new Employee();
		Employee e3 = new Employee();
		
		e1.eid=1000;		e1.name="Raja";		e1.salary=7000.90;
		e2.eid=1001;		e2.name="Rani";		e2.salary=8000.90;
		e3.eid=1002;		e3.name="Ram";		e3.salary=9000.90;

		e1.next=e2;
		e2.next=e3;
		e3.next=null;

		while(e1 != null) {

			System.out.println(e1.eid +"\t"+ e1.name +"\t"+ e1.salary);
			e1 = e1.next;
		}
	}
}







Generics in Java  Collectiop
--------------------------
	<Integer> 	,	 <Student> 	,	 <String>

	It is introduced in JDK 5.
	It is used to avoid unncessary type-casting.
	By using Generics, programmer can store only that type of object which already specified.
	If programmer will store different type of object, then it is a compile-time error.

	Benefits of Generics
	-----------------------
		1.	Type safety
		2.	Type-casting is not not required by programmer 
		3.	It checks data at the time of compilation.

import java.util.*;

class Test {

	public static void main(String[] args) {
		
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	//	Insert at begin
		list.addLast(22);	//	Insert at End 
		list.add(1,33);		//	Insert at Any position
		list.add(44);		//	Insert at last 
		list.add(55);
		list.add(3,11);
		System.out.println(list);	// 	Traversing the list 
		
		System.out.println(list.getFirst());
		System.out.println(list.getLast());
		System.out.println(list.get(3));
		
		Collections.sort(list);		//	Sort the list 
		System.out.println("After sort the list is : "+list);
		Collections.reverse(list);	//	Do reversing 
		System.out.println("After reverse the list is : "+list);
		
		System.out.println(list.indexOf(11));	//	Return the index of first occurrence
		System.out.println(list.lastIndexOf(11));	//	Return the index of last occurrence
		System.out.println(list.contains(11));
	}
}

Example: Methods of Linkedlist 
--------------------------------
import java.util.*;

class Test {

	public static void main(String[] args) {
		
		LinkedList<Integer> list1 = new LinkedList<Integer>();
		list1.addFirst(11);	//	Insert at begin
		list1.addLast(22);	//	Insert at End 
		list1.add(1,33);		//	Insert at Any position
		list1.add(44);		//	Insert at last 
		list1.add(55);
		list1.add(3,11);
		System.out.println(list1);	// 	Traversing the list 
	
		LinkedList<Integer> list2 = new LinkedList<Integer>();
		list2.addFirst(100);	//	Insert at begin
		list2.add(200);
		list2.add(300);
		System.out.println(list2);	
		
		//list1.addAll(list2);	//	Merge the linkedlist at last
		list1.addAll(2,list2);	//	Merge the linkedlist at any position
		System.out.println("After Merge two list : "+list1);
		
		list1.removeAll(list2);	//	Delete a list from another list 
		System.out.println("After remove list : "+list1);
		
		list1.remove(3);	//	Delete from any position
		System.out.println(list1);
		System.out.println("List size : "+list1.size()); // Count the number of elements
		
		list1.removeFirst();	//	Delete from first
		list1.removeLast();		//	Delete from last
		System.out.println(list1);

		list1.clear();	// Delete entire linkedlist
		System.out.println(list1);
		
		System.out.println(list1.isEmpty()); // Check the LinkedList whether it is empty or not 
	}
}


Traversing a collection 
------------------------------------------
	A collection (group of objects) can be traversed in following ways 

			1.	By toString() or directly by object 
			2.	By get() method 
			3.	By for-each loop 
			4.	By converting to array 
			5.	By Iterator interface 
			6.	By ListIterator interface 
					Forward 
					Backward 
			7.	By Enumeration interface


import java.util.*;

class Test {

	public static void main(String[] args) {
				
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	
		list.addLast(22);	 
		list.add(1,33);	
		list.add(44);		 
		list.add(55);
		list.add(3,11);
		
		System.out.println("Traversing by toString() method");
		System.out.println(list); 
		System.out.println(list.toString());


		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by get() method");
		for(int i=0;i<list.size();i++)
			System.out.print (list.get(i)+"\t");
		System.out.println();
		
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by converting to Array");
		Object arr[] = list.toArray();
		System.out.println(Arrays.toString(arr));

		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using for-each loop");
		for(Integer element : list)
			System.out.print (element +"\t");
		System.out.println();
	}
}


Iterator<Integer> itr1 = list.iterator();
----------------------------------------------
		iterator() method return the list to Iterator interface.
		Here itr1 point to base address of the LinkedList.
		Iterator is a pre-defined interface present in java.util package.
		This interface is used to traverse the collection in a single direction i.e. forward only.

hasNext()
-----------------
		This method check the existence of element , if available then return true otherwise return false.

next()
----------------------	
		This method is responsible to perform two task 

			1.	Return the element of the list 
			2.	Move the pointer to the next element of the list 



Iterator vs ListIterator 
----------------------------
	Iterator support single direction traversing whereas ListIterator support both direction traversing.

	import java.util.*;

class Test {

	public static void main(String[] args) {
				
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	
		list.addLast(22);	 
		list.add(1,33);	
		list.add(44);		 
		list.add(55);
		list.add(3,11);
		
		System.out.println("Traversing by using Iterator interface ");
		Iterator<Integer> itr1 = list.iterator();	//	iterator () return list to Iterator interface
		while(itr1.hasNext())
			System.out.print  (itr1.next() +"\t");
		System.out.println();
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using ListIterator interface (forward direction) ");
		ListIterator<Integer> itr2 = list.listIterator();
		while(itr2.hasNext())
			System.out.print  (itr2.next() +"\t");
		System.out.println();
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using ListIterator interface (backward direction) ");
		while(itr2.hasPrevious())
			System.out.print  (itr2.previous()+"\t");
		System.out.println();
	}
}





Generics in Java  Collectiop
--------------------------
	<Integer> 	,	 <Student> 	,	 <String>

	It is introduced in JDK 5.
	It is used to avoid unncessary type-casting.
	By using Generics, programmer can store only that type of object which already specified.
	If programmer will store different type of object, then it is a compile-time error.

	Benefits of Generics
	-----------------------
		1.	Type safety
		2.	Type-casting is not not required by programmer 
		3.	It checks data at the time of compilation.

import java.util.*;

class Test {

	public static void main(String[] args) {
		
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	//	Insert at begin
		list.addLast(22);	//	Insert at End 
		list.add(1,33);		//	Insert at Any position
		list.add(44);		//	Insert at last 
		list.add(55);
		list.add(3,11);
		System.out.println(list);	// 	Traversing the list 
		
		System.out.println(list.getFirst());
		System.out.println(list.getLast());
		System.out.println(list.get(3));
		
		Collections.sort(list);		//	Sort the list 
		System.out.println("After sort the list is : "+list);
		Collections.reverse(list);	//	Do reversing 
		System.out.println("After reverse the list is : "+list);
		
		System.out.println(list.indexOf(11));	//	Return the index of first occurrence
		System.out.println(list.lastIndexOf(11));	//	Return the index of last occurrence
		System.out.println(list.contains(11));
	}
}

Example: Methods of Linkedlist 
--------------------------------
import java.util.*;

class Test {

	public static void main(String[] args) {
		
		LinkedList<Integer> list1 = new LinkedList<Integer>();
		list1.addFirst(11);	//	Insert at begin
		list1.addLast(22);	//	Insert at End 
		list1.add(1,33);		//	Insert at Any position
		list1.add(44);		//	Insert at last 
		list1.add(55);
		list1.add(3,11);
		System.out.println(list1);	// 	Traversing the list 
	
		LinkedList<Integer> list2 = new LinkedList<Integer>();
		list2.addFirst(100);	//	Insert at begin
		list2.add(200);
		list2.add(300);
		System.out.println(list2);	
		
		//list1.addAll(list2);	//	Merge the linkedlist at last
		list1.addAll(2,list2);	//	Merge the linkedlist at any position
		System.out.println("After Merge two list : "+list1);
		
		list1.removeAll(list2);	//	Delete a list from another list 
		System.out.println("After remove list : "+list1);
		
		list1.remove(3);	//	Delete from any position
		System.out.println(list1);
		System.out.println("List size : "+list1.size()); // Count the number of elements
		
		list1.removeFirst();	//	Delete from first
		list1.removeLast();		//	Delete from last
		System.out.println(list1);

		list1.clear();	// Delete entire linkedlist
		System.out.println(list1);
		
		System.out.println(list1.isEmpty()); // Check the LinkedList whether it is empty or not 
	}
}


Traversing a collection 
------------------------------------------
	A collection (group of objects) can be traversed in following ways 

			1.	By toString() or directly by object 
			2.	By get() method 
			3.	By for-each loop 
			4.	By converting to array 
			5.	By Iterator interface 
			6.	By ListIterator interface 
					Forward 
					Backward 
			7.	By Enumeration interface


import java.util.*;

class Test {

	public static void main(String[] args) {
				
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	
		list.addLast(22);	 
		list.add(1,33);	
		list.add(44);		 
		list.add(55);
		list.add(3,11);
		
		System.out.println("Traversing by toString() method");
		System.out.println(list); 
		System.out.println(list.toString());


		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by get() method");
		for(int i=0;i<list.size();i++)
			System.out.print (list.get(i)+"\t");
		System.out.println();
		
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by converting to Array");
		Object arr[] = list.toArray();
		System.out.println(Arrays.toString(arr));

		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using for-each loop");
		for(Integer element : list)
			System.out.print (element +"\t");
		System.out.println();
	}
}


Iterator<Integer> itr1 = list.iterator();
----------------------------------------------
		iterator() method return the list to Iterator interface.
		Here itr1 point to base address of the LinkedList.
		Iterator is a pre-defined interface present in java.util package.
		This interface is used to traverse the collection in a single direction i.e. forward only.

hasNext()
-----------------
		This method check the existence of element , if available then return true otherwise return false.

next()
----------------------	
		This method is responsible to perform two task 

			1.	Return the element of the list 
			2.	Move the pointer to the next element of the list 



Iterator vs ListIterator 
----------------------------
	Iterator support single direction traversing whereas ListIterator support both direction traversing.

	import java.util.*;

class Test {

	public static void main(String[] args) {
				
		LinkedList<Integer> list = new LinkedList<Integer>();
		list.addFirst(11);	
		list.addLast(22);	 
		list.add(1,33);	
		list.add(44);		 
		list.add(55);
		list.add(3,11);
		
		System.out.println("Traversing by using Iterator interface ");
		Iterator<Integer> itr1 = list.iterator();	//	iterator () return list to Iterator interface
		while(itr1.hasNext())
			System.out.print  (itr1.next() +"\t");
		System.out.println();
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using ListIterator interface (forward direction) ");
		ListIterator<Integer> itr2 = list.listIterator();
		while(itr2.hasNext())
			System.out.print  (itr2.next() +"\t");
		System.out.println();
		
		System.out.println("--------------------------------------------------");
		
		System.out.println("Traversing by using ListIterator interface (backward direction) ");
		while(itr2.hasPrevious())
			System.out.print  (itr2.previous()+"\t");
		System.out.println();
	}
}

ArrayList class 
----------------------------------------------------------
It is a pre-defined class present in java.util package.
	This class is used to create a dynamic array.

	Similarity between Array and ArrayList
	------------------------------------------
		Both are sequential i.e. memory allocation in a sequence.


	Similarity between LinkedList and ArrayList
	------------------------------------------
		Both are dynamic.
		Both can store duplicate objects.


	 Array vs ArrayList
	------------------------------------------
		Array is static but ArrayList is dynamic.


	LinkedList vs ArrayList
	------------------------------------------
		ArrayList is sequential but LinkedList is not sequential.
		ArrayList internally uses array to store the elements but LinkedList internally uses double linkedlist to store elements.

		Manipulation is slow in case of ArrayList as it uses array i.e. when any element is deleted then more shifting is required whereas in case of LinkedList no shifting is required.

		ArrayList is faster & better in case sorting and fetching whereas LinkedList is better  & faster in case of manipulation.

Example : Traversing ArrayList 
--------------------------------------

import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			ArrayList<Integer> list = new ArrayList<Integer>();
			list.add(11);	// add () means add at the end 
			list.add(22);	 
			list.add(1,33);	
			list.add(44);		 
			list.add(55);
			list.add(3,11);
			
			System.out.println("Traversing by toString() method");
			System.out.println(list);
			System.out.println(list.toString());
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by get() method");
			for(int i=0;i<list.size();i++)
				System.out.print (list.get(i)+"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by converting to Array");
			Object arr[] = list.toArray();
			System.out.println(Arrays.toString(arr));
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using for-each loop");
			
			for(int element : list)
				System.out.print (element +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using Iterator interface ");
			Iterator<Integer> itr1 = list.iterator();	//	iterator () return list to Iterator interface
			while(itr1.hasNext())
				System.out.print  (itr1.next() +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using ListIterator interface (forward direction) ");
			ListIterator<Integer> itr2 = list.listIterator();
			while(itr2.hasNext())
				System.out.print  (itr2.next() +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using ListIterator interface (backward direction) ");
			while(itr2.hasPrevious())
				System.out.print  (itr2.previous()+"\t");
			System.out.println();
		}
}

Example: Methods of ArrayList
-----------------------------------
import java.util.*; 
class Test {

		public static void main(String[] args) {
			
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(11);	
		list.add(22);	 
		list.add(1,11);	
		list.add(0,44);		 
		list.add(list.size(),55);
		list.add(3,11);
		
		System.out.println(list);
		System.out.println(list.get(0));
		System.out.println(list.get(list.size()-1));
		
		System.out.println(list.contains(11));
		System.out.println(list.indexOf(11));
		System.out.println(list.lastIndexOf(11));
		
		System.out.println("Index of 11 ....");
		int index=0;
		for(Integer element : list) {
			if(element==11)
				System.out.println(index);
			index++;
		}
		
		Collections.sort(list);
		System.out.println("After sort : "+list);
		Collections.reverse(list);
		System.out.println("After reverse: "+list);
		
		list.remove(0);
		list.remove(list.size()-1);
		System.out.println(list);
		
		System.out.println(list.isEmpty());
		System.out.println(list.hashCode());
		System.out.println(list.size());
		
		list.clear();	// To make ArrayList empty
		System.out.println(list);
		}
}



Stack Collection
--------------------------
	Stack is a pre-defined class present in java.util package.
	This class store data /object in LIFO (Last In First Out) basis.
	Duplicate objects are allowed.
	Index of the Stack collection starts with 1.

import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			Stack<Character> st = new Stack<Character> ();
		
			st.push('A');
			st.push('A');
			st.push('B');
			st.push('C');
			st.push('X');
			System.out.println(st);
			
			System.out.println(st.search('X'));
			System.out.println(st.peek());	//	Top element of the Stack
			st.pop();		//	Delete the top element 
			System.out.println(st);
			System.out.println(st.empty());	
		
		}
}



Queue interface 
--------------------------------
	Queue is an interface present in util package. 
	Queue follow FIFO (First In First Out) order evaluation.
	Queue support single end insert and delete operation i.e. insert at last/rear and delete from begin/front.


Deque 
----------------
	It is an interface present in java.util package.
	Deque stands for double ended queue i.e. both side insert and delete operation.

Note:	As both Queue and Deque are interfaces , so object cannot be created directly.
		
		LinkedList is the child class of Deque and Deque is child interface of Queue.


import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			Queue<Integer> q  = new LinkedList<Integer>  ();
		Deque<Integer> dq = new LinkedList<Integer>  ();
		
		q.add(11); // add at last 
		q.add(21);
		q.add(31);
		q.add(11);
		q.add(21);
		q.add(51);
		System.out.println(q);
		q.remove();	// remove from first 
		System.out.println(q);
		System.out.println(q.size());
		System.out.println(q.contains(11));
		System.out.println(q.isEmpty());
		System.out.println(q.hashCode());
		q.clear();
		System.out.println(q);
		
		dq.add(11);
		dq.addFirst(21);
		dq.add(31);
		dq.addLast(11);
		dq.addFirst(21);
		dq.add(51);
		System.out.println(dq);
		dq.removeFirst();
		dq.removeLast();
		
		}
}


HashSet and TreeSet 
-------------------------------
	Both are pre-defined class present in java.util package.
	HashSet and TreeSet both evalulate the list on the basis of object value not on the basis of index.
	Both cannot store duplciate objects.

	Only difference is , HashSet store data in a random order whereas TreeSet store data in an ascending order.






[6:33 PM, 2/2/2021] +91 99379 17604: ArrayList class 
----------------------------------------------------------
It is a pre-defined class present in java.util package.
	This class is used to create a dynamic array.

	Similarity between Array and ArrayList
	------------------------------------------
		Both are sequential i.e. memory allocation in a sequence.


	Similarity between LinkedList and ArrayList
	------------------------------------------
		Both are dynamic.
		Both can store duplicate objects.


	 Array vs ArrayList
	------------------------------------------
		Array is static but ArrayList is dynamic.


	LinkedList vs ArrayList
	------------------------------------------
		ArrayList is sequential but LinkedList is not sequential.
		ArrayList internally uses array to store the elements but LinkedList internally uses double linkedlist to store elements.

		Manipulation is slow in case of ArrayList as it uses array i.e. when any element is deleted then more shifting is required whereas in case of LinkedList no shifting is required.

		ArrayList is faster & better in case sorting and fetching whereas LinkedList is better  & faster in case of manipulation.

Example : Traversing ArrayList 
--------------------------------------

import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			ArrayList<Integer> list = new ArrayList<Integer>();
			list.add(11);	// add () means add at the end 
			list.add(22);	 
			list.add(1,33);	
			list.add(44);		 
			list.add(55);
			list.add(3,11);
			
			System.out.println("Traversing by toString() method");
			System.out.println(list);
			System.out.println(list.toString());
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by get() method");
			for(int i=0;i<list.size();i++)
				System.out.print (list.get(i)+"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by converting to Array");
			Object arr[] = list.toArray();
			System.out.println(Arrays.toString(arr));
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using for-each loop");
			
			for(int element : list)
				System.out.print (element +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using Iterator interface ");
			Iterator<Integer> itr1 = list.iterator();	//	iterator () return list to Iterator interface
			while(itr1.hasNext())
				System.out.print  (itr1.next() +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using ListIterator interface (forward direction) ");
			ListIterator<Integer> itr2 = list.listIterator();
			while(itr2.hasNext())
				System.out.print  (itr2.next() +"\t");
			System.out.println();
			
			System.out.println("--------------------------------------------------");
			
			System.out.println("Traversing by using ListIterator interface (backward direction) ");
			while(itr2.hasPrevious())
				System.out.print  (itr2.previous()+"\t");
			System.out.println();
		}
}

Example: Methods of ArrayList
-----------------------------------
import java.util.*; 
class Test {

		public static void main(String[] args) {
			
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(11);	
		list.add(22);	 
		list.add(1,11);	
		list.add(0,44);		 
		list.add(list.size(),55);
		list.add(3,11);
		
		System.out.println(list);
		System.out.println(list.get(0));
		System.out.println(list.get(list.size()-1));
		
		System.out.println(list.contains(11));
		System.out.println(list.indexOf(11));
		System.out.println(list.lastIndexOf(11));
		
		System.out.println("Index of 11 ....");
		int index=0;
		for(Integer element : list) {
			if(element==11)
				System.out.println(index);
			index++;
		}
		
		Collections.sort(list);
		System.out.println("After sort : "+list);
		Collections.reverse(list);
		System.out.println("After reverse: "+list);
		
		list.remove(0);
		list.remove(list.size()-1);
		System.out.println(list);
		
		System.out.println(list.isEmpty());
		System.out.println(list.hashCode());
		System.out.println(list.size());
		
		list.clear();	// To make ArrayList empty
		System.out.println(list);
		}
}



Stack Collection
--------------------------
	Stack is a pre-defined class present in java.util package.
	This class store data /object in LIFO (Last In First Out) basis.
	Duplicate objects are allowed.
	Index of the Stack collection starts with 1.

import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			Stack<Character> st = new Stack<Character> ();
		
			st.push('A');
			st.push('A');
			st.push('B');
			st.push('C');
			st.push('X');
			System.out.println(st);
			
			System.out.println(st.search('X'));
			System.out.println(st.peek());	//	Top element of the Stack
			st.pop();		//	Delete the top element 
			System.out.println(st);
			System.out.println(st.empty());	
		
		}
}



Queue interface 
--------------------------------
	Queue is an interface present in util package. 
	Queue follow FIFO (First In First Out) order evaluation.
	Queue support single end insert and delete operation i.e. insert at last/rear and delete from begin/front.


Deque 
----------------
	It is an interface present in java.util package.
	Deque stands for double ended queue i.e. both side insert and delete operation.

Note:	As both Queue and Deque are interfaces , so object cannot be created directly.
		
		LinkedList is the child class of Deque and Deque is child interface of Queue.


import java.util.*; 
class Test {

		public static void main(String[] args) {
			
			Queue<Integer> q  = new LinkedList<Integer>  ();
		Deque<Integer> dq = new LinkedList<Integer>  ();
		
		q.add(11); // add at last 
		q.add(21);
		q.add(31);
		q.add(11);
		q.add(21);
		q.add(51);
		System.out.println(q);
		q.remove();	// remove from first 
		System.out.println(q);
		System.out.println(q.size());
		System.out.println(q.contains(11));
		System.out.println(q.isEmpty());
		System.out.println(q.hashCode());
		q.clear();
		System.out.println(q);
		
		dq.add(11);
		dq.addFirst(21);
		dq.add(31);
		dq.addLast(11);
		dq.addFirst(21);
		dq.add(51);
		System.out.println(dq);
		dq.removeFirst();
		dq.removeLast();
		
		}
}


HashSet and TreeSet 
-------------------------------
	Both are pre-defined class present in java.util package.
	HashSet and TreeSet both evalulate the list on the basis of object value not on the basis of index.
	Both cannot store duplciate objects.

	Only difference is , HashSet store data in a random order whereas TreeSet store data in an ascending order.

import java.util.*;
public class Test  {

	public static void main(String[] args) {
		
		HashSet<Integer> set1 = new HashSet<Integer>();
		TreeSet<Integer> set2 = new TreeSet<Integer>();
		
		int arr[] = {11,11,22,2,3,2,1,1,11,22,22,11,1,12};
		System.out.println("Array is : "+Arrays.toString(arr));
		
		for(int element : arr) {
			
			set1.add(element);
			set2.add(element);
		}
		System.out.println("HashSet is : "+set1);
		System.out.println("TreeSet is : "+set2);
		
		System.out.println(set1.size());
		System.out.println(set1.contains(11));
		set1.remove(11);	// 11 is treated as value 
		System.out.println("HashSet is : "+set1);
	}
}
D:\5-6>javac Test.java

D:\5-6>java Test
Array is : [11, 11, 22, 2, 3, 2, 1, 1, 11, 22, 22, 11, 1, 12]
HashSet is : [1, 2, 3, 22, 11, 12]
TreeSet is : [1, 2, 3, 11, 12, 22]
6
true
HashSet is : [1, 2, 3, 22, 12]



HashMap , Hashtable and TreeMap
---------------------------------------------------------

	All the above three classes store objects on the basis of key.
	{k:v} 
	
	key can be any type of object and value can be any type of object.

	Duplicate keys are not allowed i.e. it will be replaced with updated values.
	Duplicate object values are allowed.

	HashMap 	:	It stores keys in a random order.
	TreeMap 	:	It stores keys in an ascending order 
	Hashtable 	:	It stores keys in a random order but it is synchronized.

synchronized 	:`	It supports locking


import java.util.*;
public class Test  {

	public static void main(String[] args) {
		
		HashMap<Integer, String>   map1 = new HashMap<Integer,String>();
		Hashtable<Integer, String> map2 = new Hashtable<Integer,String>();
		TreeMap<Integer, String>   map3 = new TreeMap<Integer,String>();
		
		map1.put(100, "C");
		map1.put(101, "C++");
		map1.put(100, "Core Java");
		map1.put(10, "C#");
		map1.put(11, "Adv. Java");
		map1.put(20, "HTML");
		map1.put(7, "CSS");		
		System.out.println(map1);
		
		map2.put(100, "C");
		map2.put(101, "C++");
		map2.put(100, "Core Java");
		map2.put(10, "C#");
		map2.put(11, "Adv. Java");
		map2.put(20, "HTML");
		map2.put(7, "CSS");		
		System.out.println(map2);
		
		map3.put(100, "C");
		map3.put(101, "C++");
		map3.put(100, "Core Java");
		map3.put(10, "HTML");
		map3.put(11, "Adv. Java");
		map3.put(20, "HTML");
		map3.put(7, "CSS");		
		System.out.println(map3);
		
		System.out.println(map2.size());
		System.out.println(map2.isEmpty());
		System.out.println(map2.get(100));
		System.out.println(map2.values());
		System.out.println(map2.keySet());
		System.out.println(map2.containsKey(100));
		System.out.println(map2.containsValue("C"));
		map2.replace(100, "Hibernate");
		System.out.println(map2);
		map2.remove(100);
		System.out.println(map2);
	}
}
D:\5-6>java Test
Array is : [11, 11, 22, 2, 3, 2, 1, 1, 11, 22, 22, 11, 1, 12]
HashSet is : [1, 2, 3, 22, 11, 12]
TreeSet is : [1, 2, 3, 11, 12, 22]
6
true
HashSet is : [1, 2, 3, 22, 12]

D:\5-6>java Test.java
{100=Core Java, 20=HTML, 101=C++, 7=CSS, 10=C#, 11=Adv. Java}
{10=C#, 20=HTML, 7=CSS, 101=C++, 100=Core Java, 11=Adv. Java}
{7=CSS, 10=HTML, 11=Adv. Java, 20=HTML, 100=Core Java, 101=C++}
6
false
Core Java
[C#, HTML, CSS, C++, Core Java, Adv. Java]
[10, 20, 7, 101, 100, 11]
true
false
{10=C#, 20=HTML, 7=CSS, 101=C++, 100=Hibernate, 11=Adv. Java}
{10=C#, 20=HTML, 7=CSS, 101=C++, 11=Adv. Java}

D:\5-6>




Vector 
--------------------
	It is a pre-defined class present in java.util package.
	It evaluates the list on the basis of object value and index.

	It is synchronized.

Duplicate elements are allowed. 

addElement()	:	Value-wise addition 
add()			:	Index-wise addition 

removeElement()	:	Value-wise deletion 
remove()		:	Index-wise deletion 

import java.util.*;
public class Test  {

	public static void main(String[] args) {
		
		Vector<Integer> v = new Vector<Integer>();
		v.addElement(11);	//	 Value-wise insertion
		v.addElement(21);
		v.addElement(31);
		v.addElement(41);
		System.out.println(v);
		v.add(1,10);		//	index-wise insertion
		v.add(2,20);
		System.out.println(v);
		v.remove(0);		//	Delete on the basis of index
		v.removeElement(41);	//	Delete on the basis of value
		System.out.println(v);
		System.out.println(v.size());
		System.out.println(v.contains(11));
		v.clear();
		System.out.println(v);
		
	}
}
D:\5-6>java Test.java
[11, 21, 31, 41]
[11, 10, 20, 21, 31, 41]
[10, 20, 21, 31]
4
false
[]
Exception Handling 
--------------------------------------------------
	Exception :	 It is a situation where program terminates abnoramlly. 

	To avoid the abnoraml termination , we have to handle the Exception i.e. Exception handling.

	In Java, Exception may occurs at the time of compilation or at execution time.

	Broadly Exception divided into two types 
		1.	Checked Exception / Compile-time Exception
		2.	Unchecked Exception / Run-time Exception

	Each & every Exceptoion is a pre-defined class and Java also given a  facility to create custom/User-defined Exception. 

Tree Structure of Exception 
------------------------------------

Object
	|
	|->	Throwable 
			|->	Error 
					|->	AssertionError
					|->	StackOverflowError // call main() method from main()
						..................
						.................
			|->	Exception
					|->	IOException 
							|->	EOFException 
							|->	FileNotFoundException 
					|->	RuntimeException
							|->	ArithmeticException
							|->	IndexOutOfBoundsException
									|->	ArrayIndexOutOfBoundsException
									|->	StringIndexOutOfBoundsException
							|->	NullPointerException
							|->	NumberFormatException
							|->	NoSuchFieldException
							|->	InputMismatchException 
							...........................
							...........................

					|->	UnknownHostException
					|->	InterruptedException
						.........................
						.........................


NOTE:
	RuntimeException and its all sub-classes are Unchecked Exception. 

Java support 5 keywords to work with the Exception
	1.	try 
	2.	catch 
	3.	throw 
	4.	throws 
	5.	finally



try-block 
------------
	This block contains Exception generate codes i.e. if one or more statements may generate  exception in future then that should be placed within try-block.

	
	try-block is not an independent block i.e. it depends on catch or finally block. 

Catch-block 
--------------------------------
	It is known as Exception handled block.
	Its execution is optional, catch-block will execute after satisfied following conditions 
			1.	The codes within try-block should generate the Exception. 
			2.	The corespoding Exception handler should be handled in catch.

	syntax 
	----------
		try {

			// Exception generate codes 
		}
		catch(Throwable object) {

			// Exception Handle codes 
		}

Example: try-catch block 
-----------------------------
class Test {

	public static void main(String[] args) {
		

		System.out.println("Hello");	

		try {
		
			System.out.println(args[0]);
		}
		catch(ArrayIndexOutOfBoundsException are) {

			System.out.println("Exception is Handled ..:) ");
		}
		
		System.out.println("Terminates Normally ...:) ");
	}
}


Note:	In the above case , when programmer not passing arguments from commandline then JVM automatcially create the object of ArrayIndexOutOfBoundsException class and pass/throws to user. and programmer bound to handle it within catch-block. 


Note:	Multiple catch blocks are allowed for a single try-block , but only one catch-block will be executed at a single time.

class Test {

	public static void main(String[] args) {
		

		System.out.println("Hello");	

		try {
			System.out.println(Integer.parseInt(args[0]) / Integer.parseInt(args[1]));
		}
		catch(ArrayIndexOutOfBoundsException are) {
			System.out.println("Plz enter arguments from commandline ...:) ");
		}
		catch(ArithmeticException ae) {
			System.out.println("Donot divide by 0 ...:) ");
		}
		catch(NumberFormatException ne) {
			System.out.println("Plz enter numeric only ...:) ");
		}
		
		System.out.println("Terminates Normally ...:) ");
	}
}


Exception :	In Java, Exception is a pre-defined class present in java.lang package.
			Exception class can handle any type of exception generated in Java program.
			Exception class is the super-class of all types of Exception in Java.


class Test {

	public static void main(String[] args) {
		

		System.out.println("Hello");	

		try {
			System.out.println(Integer.parseInt(args[0]) / Integer.parseInt(args[1]));
		}
		catch(Exception e) {
			System.out.println("Handle By super-class ...:) ");
			e.printStackTrace();	//	It shows the details about the exception
		}

		System.out.println("Terminates Normally ...:) ");
	}
}


throw 
--------------------
	It is a keyword in Java, which is used to generate any type of exception i.e. exception may be pre-defined or User-defined exception.

	syntax 
	----------
		throw Throwable_instance;

		Ex:	throw new Exception()
			throw new ArithmeticException();
			throw new RuntimeException();



	How to create custom/User-defined exception
	--------------------------------------------
		1.	Create an user-defined class 
		2.	Make this class as sub-class of any type of pre-defined Exception
		3.	Create the object of User-defined class 
		4.	Raise that object/exception using throw keyword.
		5.	Handle by catch block 

import java.util.*;
class EvenExcption extends  Exception {
	
}

class Test{
	
	public static void main(String[] args) {
		
		System.out.println("Hello");	

		Scanner sc = new Scanner (System.in);
		System.out.println("Enter a number ");
		int num = sc.nextInt();

		if(num % 2 == 0 ) {

			try {

				System.out.println("User-defined Exception Occurs ...:) ");
				throw new EvenExcption();	//	 Here exception is generated 	
			}
			catch(EvenExcption e) {
				System.out.println("User-defined Exception Handled ...:) ");
			}
			
		}
		else {
			System.out.println("It is an odd number ..:) ");
		}

		System.out.println("Terminate Normally");
		System.out.println("Hi");
	}
}


throws
---------------------------------
	This keyword is used to pass the exception from called method/constructor to caller method/constructor.

	Technique to pass the exception from called method/constructor to caller method/constructor is known as Exception propagation.




throws
---------------------------------
	This keyword is used to pass the exception from called method/constructor to caller method/constructor.

	Technique to pass the exception from called method/constructor to caller method/constructor is known as Exception propagation.
class Test{
	
	void doSomething() throws Exception {
		System.out.println("doSomething() method");
		System.out.println("3");
		throw new Exception();
	}
	void display() throws Exception{

		System.out.println("display() method ");
		doSomething();
		System.out.println("1");
	}
	void show () throws Exception {

		System.out.println("show() method ");
		display();
		System.out.println("2");
	}

	public static void main(String[] args) {
		
		System.out.println("Hello");	

		try {
		
			new Test() . show();
		}
		catch(Exception e) {
			System.out.println("Handle by Caller ");
		}
		

		System.out.println("Terminate Normally");
		System.out.println("Hi");
	}
}


throw vs throws 
----------------------
	->	 throw is used to generate the exception whereas throws is used to pass the exception to caller.

	->	throw can be placed within function body whereas throws only can be placed with the function prototype.


finally block 
------------------------------------------------------------
	This block is very similar to catch block.
	finally is not an independent block , it depends on try-block.

	catch vs finally 
	----------------------
		->	Catch-block may or maynot execute whereas finally block must execute.
		->	More than one catch-block allowed for a single try whereas as only one finally is allowed.
		->	Catch-block is used to handle the exception but finally block is used to handle the unreachable statements.

class Test{
	

	public static void main(String[] args) {
		
		System.out.println("Hi");

		try {
			System.out.println("try");
			throw new Exception();
		}
		catch (Exception e) {
			System.out.println("catch-block");
		}
		finally {
			System.out.println("finally");
		}

		System.out.println("Hello");
	}
}


--------------------

class Test{
	
	int x = 123;
	int show() throws Exception {  // passed exception to main

		System.out.println("show() ");

		try {

			System.out.println("try-block");
			throw new Exception();
		}
		catch(Exception e) {

			System.out.println("Exception Handled ");
			throw new Exception();
		}
		finally {
			
			System.out.println("finally - block ");
			x++;
			return x; 
		}
	}
	public static void main(String[] args) throws Exception  { // passed exception to JVM
		
		System.out.println("Hello");

		int res = new Test() . show();
		System.out.println("Value of x is : "+res);

		System.out.println("Terminate Normally");
	}
}


Restriction of throws keyword in case of method Overriding 
-----------------------------------------------------------------
	1.	If method within super-class already throws the Exception then method within sub-class may or maynot throws. 


java.io package / File Handling in Java 
---------------------------------------------
	File is a container which store data permanently.
	Data can be stored permanently by two ways 
		1.	With the help of File 
		2.	With the help of Database 


	Following are operation can be performed with the file 
	---------------------------------------------------------------	
		Create new file 
		Create new folder 
		Create nessted folder 

		Delete file 
		Delete folder 

		Check existence 
		Find Length 

		Check Permission 
		Make Readble 

		Compare two files 
		File Renaming 	
		Check readonly 
		make readonly 
		check last modified time 

		Copy and Paste 
		R/W operation 
		Merginig 
		R/W image / video / audio files 


In Java, File  is  a pre-defined class present in java.io package.
This class is used to create or manipulate the File. 
This class is not responsible to do read & write operation. 


Constructor of File 
------------------------------------
	File (String File_name )
	File (String path , String File_name )

Note:	If path is not specified then it indicates current folder. 



import java.io.*;
class Test  {


	public static void main(String[] args) throws Exception {
		

		File f1 = new File ("hello.txt");
		System.out.println(f1.getAbsolutePath()); // return the full path of the file
		System.out.println(f1.exists());
		System.out.println(f1.createNewFile());
	}
}

Methods of File class 
--------------------------------
import java.io.*;
class Test  {


	public static void main(String[] args) throws Exception {
		

		File f1 = new File ("hello.txt");
		File f2 = new File ("G:/","hi.txt");
		File f3 = new File ("ok");
		File f4 = new File ("a/b/c/d"); // nested folder 
		
		
		System.out.println(f1.createNewFile());
		System.out.println(f2.createNewFile());
		System.out.println(f3.mkdir());
		System.out.println(f4.mkdirs());

		System.out.println(f1.length());
		System.out.println(f1.canRead());
		System.out.println(f1.canWrite());
		System.out.println(f1.isHidden());
		
		f1.setWritable(false); // Make Read only
		f1.setWritable(true);  
	}
}





throws
---------------------------------
	This keyword is used to pass the exception from called method/constructor to caller method/constructor.

	Technique to pass the exception from called method/constructor to caller method/constructor is known as Exception propagation.
class Test{
	
	void doSomething() throws Exception {
		System.out.println("doSomething() method");
		System.out.println("3");
		throw new Exception();
	}
	void display() throws Exception{

		System.out.println("display() method ");
		doSomething();
		System.out.println("1");
	}
	void show () throws Exception {

		System.out.println("show() method ");
		display();
		System.out.println("2");
	}

	public static void main(String[] args) {
		
		System.out.println("Hello");	

		try {
		
			new Test() . show();
		}
		catch(Exception e) {
			System.out.println("Handle by Caller ");
		}
		

		System.out.println("Terminate Normally");
		System.out.println("Hi");
	}
}


throw vs throws 
----------------------
	->	 throw is used to generate the exception whereas throws is used to pass the exception to caller.

	->	throw can be placed within function body whereas throws only can be placed with the function prototype.


finally block 
------------------------------------------------------------
	This block is very similar to catch block.
	finally is not an independent block , it depends on try-block.

	catch vs finally 
	----------------------
		->	Catch-block may or maynot execute whereas finally block must execute.
		->	More than one catch-block allowed for a single try whereas as only one finally is allowed.
		->	Catch-block is used to handle the exception but finally block is used to handle the unreachable statements.

class Test{
	

	public static void main(String[] args) {
		
		System.out.println("Hi");

		try {
			System.out.println("try");
			throw new Exception();
		}
		catch (Exception e) {
			System.out.println("catch-block");
		}
		finally {
			System.out.println("finally");
		}

		System.out.println("Hello");
	}
}


--------------------

class Test{
	
	int x = 123;
	int show() throws Exception {  // passed exception to main

		System.out.println("show() ");

		try {

			System.out.println("try-block");
			throw new Exception();
		}
		catch(Exception e) {

			System.out.println("Exception Handled ");
			throw new Exception();
		}
		finally {
			
			System.out.println("finally - block ");
			x++;
			return x; 
		}
	}
	public static void main(String[] args) throws Exception  { // passed exception to JVM
		
		System.out.println("Hello");

		int res = new Test() . show();
		System.out.println("Value of x is : "+res);

		System.out.println("Terminate Normally");
	}
}


Restriction of throws keyword in case of method Overriding 
-----------------------------------------------------------------
	1.	If method within super-class already throws the Exception then method within sub-class may or maynot throws. 


java.io package / File Handling in Java 
---------------------------------------------
	File is a container which store data permanently.
	Data can be stored permanently by two ways 
		1.	With the help of File 
		2.	With the help of Database 


	Following are operation can be performed with the file 
	---------------------------------------------------------------	
		Create new file 
		Create new folder 
		Create nessted folder 

		Delete file 
		Delete folder 

		Check existence 
		Find Length 

		Check Permission 
		Make Readble 

		Compare two files 
		File Renaming 	
		Check readonly 
		make readonly 
		check last modified time 

		Copy and Paste 
		R/W operation 
		Merginig 
		R/W image / video / audio files 


In Java, File  is  a pre-defined class present in java.io package.
This class is used to create or manipulate the File. 
This class is not responsible to do read & write operation. 


Constructor of File 
------------------------------------
	File (String File_name )
	File (String path , String File_name )

Note:	If path is not specified then it indicates current folder. 



import java.io.*;
class Test  {


	public static void main(String[] args) throws Exception {
		

		File f1 = new File ("hello.txt");
		System.out.println(f1.getAbsolutePath()); // return the full path of the file
		System.out.println(f1.exists());
		System.out.println(f1.createNewFile());
	}
}

Methods of File class 
--------------------------------
import java.io.*;
class Test  {


	public static void main(String[] args) throws Exception {
		

		File f1 = new File ("hello.txt");
		File f2 = new File ("G:/","hi.txt");
		File f3 = new File ("ok");
		File f4 = new File ("a/b/c/d"); // nested folder 
		
		
		System.out.println(f1.createNewFile());
		System.out.println(f2.createNewFile());
		System.out.println(f3.mkdir());
		System.out.println(f4.mkdirs());

		System.out.println(f1.length());
		System.out.println(f1.canRead());
		System.out.println(f1.canWrite());
		System.out.println(f1.isHidden());
		
		f1.setWritable(false); // Make Read only
		f1.setWritable(true);  

		File f5 = new File ("std.txt");
		System.out.println(f1.renameTo(f5));
		
		System.out.println(f5.delete());
		System.out.println(f3.delete());
	}
}
Note : delete() is used to delete a file and folder. 



Read / Write  operation with File in a Character format 
--------------------------------------------------------------------------
	java.io pacakge provides two different class to do so 

		1.	FileInputStream
		2.	FileOutputStream 


	FileInputStream :	It is used to read data from file in  a character format with the help of read() method. 

	Constructor
	------------------------
		FileInputStream (String File_name);
		FileInputStream (File object)

	FileOutputStream :	It is used to write data into file in  a character format with the help of write() method. 


	Constructor
	------------------------
		//	Create or replace 
		FileOutputStream (String File_name);
		FileOutputStream (File object)

		//	Create or append 
		FileOutputStream (String File_name, true);
		FileOutputStream (File object , true)


Note:	Before read data , FileInputStream always check the file existence , if file not available, then terminate the program abnoramlly by throwing FileNotFoundException. 


		Before write data , FileOutputStream always check the File existence, if file not available then create a new File otherwise replace/append into existing file. 

Example: 	Create or repalce 
			Create or append 
			Any type of file 
	---------------------------------------------------------
import java.io.*;
public class Test {
	
	public static void main(String[] args) throws  Exception{
		
		FileInputStream fis = new FileInputStream("hello.txt");
		FileOutputStream fos = new FileOutputStream("hi.txt",true);
		
		int ch , count=0;
		while((ch = fis.read()) != -1) { // -1 for EOF // read char from file 
			
			fos.write(ch); // write char intof file 
			if(ch=='e') 
				count++;
		}
		System.out.println("Success !!!!!");
		System.out.println(count);
		fis.close();
		fos.close();
	}
}

Read / Write  operation with File in a String format 
--------------------------------------------------------------------------
	java.io pacakge provides two different class to do so 

		1.	BufferedReader
		2.	BufferedWriter


	BufferedReader :	It is used to read data from file in  a String format with the help of readLine() method. 

	Constructor
	------------------------
		BufferedReader (new FileReader(String File_name));
		BufferedReader (new FileReader(File object));
		

	BufferedWriter :	It is used to write data into file in  a String format with the help of write() method. 


	Constructor
	------------------------
		//	Create or replace 
		BufferedWriter (new FileWriter(String File_name));
		BufferedWriter (new FileWriter(File object));

		//	Create or append 
 
		BufferedWriter (new FileWriter(String File_name,true));
		BufferedWriter (new FileWriter(File object,true));


Note:	Before read data , BufferedReader always check the file existence , if file not available, then terminate the program abnoramlly by throwing FileNotFoundException. 


		Before write data , BufferedWriter always check the File existence, if file not available then create a new File otherwise replace/append into existing file. 
		

import java.io.*;
public class Test {
	
	public static void main(String[] args) throws  Exception{
		
		BufferedReader br = new BufferedReader(new FileReader("hello.txt"));
		BufferedWriter bw = new BufferedWriter(new FileWriter("hi.txt"));
		
		String line;
		while((line = br.readLine()) != null) { // read line by line 
			
			System.out.println(line); // print in console 
			bw.write(line+"\n"); // write into file 
			Thread.sleep(1000); // 
		}
		
		System.out.println("Done ....:_) ");
		bw.close();
		br.close();
	}
}


Read / Write  operation with File in an Object format 
--------------------------------------------------------------------------
	java.io pacakge provides two different class to do so 

		1.	ObjectInputStream
		2.	ObjectOutputStream


	ObjectInputStream :	It is used to read object from file  with the help of readObject() method. 

	Constructor
	------------------------
		ObjectInputStream (new FileInputStream(String File_name));
		ObjectInputStream (new FileInputStream(File object));
		

	ObjectOutputStream :	It is used to write object into file  with the help of writeObject() method. 


	Constructor
	------------------------
		//	Create or replace 
		ObjectOutputStream (new FileOutputStream(String File_name));
		ObjectOutputStream (new FileOutputStream(File object));

		//	Create or append 
		ObjectOutputStream (new FileOutputStream(String File_name,true));
		ObjectOutputStream (new FileOutputStream(File object,true));



Object Serialization 	:	Process to write object into a file is known as Serialization.
							
							Object to be serialized , corespoding class should be the sub-class of Serializable interface.
							
							Serializable is a marker interface in Java.
							
							marker interface indicates to JVM, object is created for a very special prupose.




Object De-Serialization 	:	Process to read object from the file is known as De-Serialization.



transient keyword 
----------------------------
	It is a keyword in Java , which is used to declare a transient  variable.
	If the variable is transient, then it cannot be serialized i.e. value of that variable cannot not write into file.

import java.io.*;
class Student implements Serializable{
	int roll ; 
	String name ;
	transient double cgpa;
	String branch;
	transient String college;
	long mobileno;
}

public class Test {
	
	public static void main(String[] args) throws  Exception{
		
		Student s1 = new Student ();
		s1.roll=100;	
		s1.name="Kausik";
		s1.cgpa=9.1;
		s1.branch="CSE";
		s1.college="GCE";
		s1.mobileno=90909090;
		
		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("std.txt"));
		oos.writeObject(s1);
		
		System.out.println("Done ...:) ");
		oos.close();


		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("std.txt"));
		Student s2 = (Student) ois.readObject();
		
		System.out.println("Roll        : "+s2.roll);
		System.out.println("Name        : "+s2.name);
		System.out.println("Cgpa        : "+s2.cgpa);
		System.out.println("Branch      : "+s2.branch);
		System.out.println("College     : "+s2.college);
		System.out.println("Mobile - No : "+s2.mobileno);
				
	}
}



Graphics in Java
----------------------------------------------------------
	
	Application are basically two types 

		1.	CUI (Command User Interface)
			----------------------------------
					Application , which only can be interacted by command. 
					CUI Application are not interactive from end user point of view.

		2.	GUI (Graphical User Interface)

					Application, which provides a window/frame to interact with. 
					GUI Applications are very interactive. 

		GUI Application can be created by using following packages 

				->	java.awt 
				->	javax.swing 
				->	java.applet 
				->	javafx 



		java.awt package provides some classes & interfaces to create a GUI.

		Tree Structure of awt package 
		---------------------------------
			|	--->	LayoutManager 
							|
							|	--->		BorderLayout 
							|	--->		FlowLayout 
							|	--->		GridLayout 	
			|	--->	Color 
			|	--->	Font 
			|	--->	Graphics 
			|	--->	Component
							|	--->		Label 
							|	--->		TextField 
							|	--->		TextArea 
							|	--->		Scrollbar 
							|	--->		ScrollPane 
							|	--->		Button 
							|	--->		Canvas 
							|	--->		Checkbox 
							|	--->		CheckboxGroup 							 
							|	--->		Container 
												|	--->	Frame 
												|	--->	Dialog 
												|	--->	Window 
												|	--->	Panel 

			
			

----------------------------------------------------------------

Frame
-----------------------
	It is a pre-defined class present in java.awt package. 
	It provides a window , in which maximize , minimize and close option available. 

How to create a Frame 
-------------------------
	Frame can be constructed by two ways 

		1.	By creating object of Frame class directly i.e. association 
		2.	By extending Frame class  i.e. Inheritance 
		

	1.	By creating object of Frame class directly i.e. association 
-----------------------------------------------------------------------
import java.awt.*;
public class Test {
	
	public static void main(String[] args) {
		
		Frame f1 = new Frame ();
	
		f1.setVisible(true);
		f1.setSize(300, 200);
		f1.setLocation(600, 200);
		f1.setTitle("My Frame");
		f1.setBackground(Color.red);
		f1.setResizable(false);
		
	}
}

2.	By extending Frame class  i.e. Inheritance 
----------------------------------------------------------------------
import java.awt.*;
public class Test extends Frame {
	
	Test() {
		
		setVisible(true);
		setSize(400, 400);
		setLocation(500, 200);
		setTitle("My Frame");
		setBackground(Color.green);
		setResizable(false);
		
	}
	public static void main(String[] args) {
		
		new Test() ;
		
	}
}



javax.swing 
----------------------------------------------

	swing is a pre-defined package present in javax package.
	It is the advanced of awt. 
	Swing support all the UI component of awt and some new component also available in swing. 

	awt uses the UI resource of O/S , so looks is totally depend on O/S. 
	All swing components are purely developed in Java , so looks is same for all O/S. 

	In otherwords ,  awt produce platform dependent UI whereas swing produce platform independent UI.

	Generally swing components are starting with letter J.

	Example :	Frame 		->	JFrame 
				Button		->	JButton 
				TextField 	->	JTextField



How to create a swing Frame using Inheritance
--------------------------------------------------------------

import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	void createGUI() {
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Close the Frame
		setVisible(true);
		setSize(400, 400);
		setLocation(500, 200);
		setTitle("My Frame");
		getContentPane().setBackground(Color.green); // Set the background color 
		setResizable(false);
		
	}
	public static void main(String[] args) {
		
		new Test() .createGUI();
		
	}
}



How to create a swing Frame using association
--------------------------------------------------------------

import java.awt.*;
import javax.swing.*;

public class Test {
	
	public static void main(String[] args) {
		
		JFrame f1 = new JFrame ();
	
		f1.setVisible(true);
		f1.setSize(300, 200);
		f1.setLocation(300, 200);
		f1.setTitle("My Frame");
		f1.setResizable(false);
		
	}
}






import java.awt.*;
import javax.swing.*;

public class Test {
	
	public static void main(String[] args) {
		
		JFrame f1 = new JFrame ();
		f1.setVisible(true);
		f1.setSize(300, 200);	//	Here 300 is width & 200 is height
		f1.setLocation(50, 200);
	
		JDialog d1 = new JDialog ();
		d1.setVisible(true);
		d1.setSize(300, 200);
		d1.setLocation(400, 200);
		
		JWindow w1 = new JWindow ();
		w1.setVisible(true);
		w1.setSize(300, 200);
		w1.setLocation(750, 200);
	
	}
}
LayoutManager
------------------------
	Java support following layout for designing 

		1.	BorderLayout
		2.	FlowLayout
		3.	GridLayout 


BorderLayout
--------------------------------
	It is a pre-defined class present in java.awt pacakge.
	It provides a pre-defined style/format to arrange the UI components.
	BorderLayout provides five location to add UI components

		1.	EAST 
		2.	WEST 
		3.	CENTER	(By default) 
		4.	NORTH 
		5.	SOUTH 


	Frame/Dialog/Window  container support BorderLayout by default. 
	To change the layout of a container , we can use setLayout() method. 

	Example:	setLayout(new FlowLayout());


FlowLayout
---------------------------------
	It is a  pre-defined class present in awt pacakge.
	UI components added to the FlowLayout , always add in the center of first row.

	Applet/Panel support FlowLayout by default.



GridLayout
---------------------------------
	It is a  pre-defined class present in awt pacakge.
	GridLayout divide the conatiner into number of rows & columns. 

User-defined layout 
-----------------------------
	If a programmer is not satisified with any pre-defined layout, then it is possible to create custom layout by using following code. 

	setLayout(null);	

Example: BorderLayout
-------------------------
import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		setLayout(new BorderLayout());
		
		JButton b1 = new JButton("Submit");
		JButton b2 = new JButton("Reset");
		JButton b3 = new JButton("OK");
		JButton b4 = new JButton("Register");
		JButton b5 = new JButton("Login");

		add (b1,BorderLayout.EAST);	//	Add button into Frame 
		add (b2,BorderLayout.WEST);	//	Add button into Frame 
		add (b3,BorderLayout.NORTH);	//	Add button into Frame 
		add (b4,BorderLayout.SOUTH);	//	Add button into Frame 
		add (b5,BorderLayout.CENTER);	//	Add button into Frame 
		

		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}

Example: FlowLayout and GridLayout
--------------------------------------
import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		setLayout(new FlowLayout());
		setLayout(new GridLayout(3,2));

		JButton b1 = new JButton("Submit");
		JButton b2 = new JButton("Reset");
		JButton b3 = new JButton("OK");
		JButton b4 = new JButton("Register");
		JButton b5 = new JButton("Login");

		add (b1);	//	Add button into Frame 
		add (b2);	//	Add button into Frame 
		add (b3);	//	Add button into Frame 
		add (b4);	//	Add button into Frame 
		add (b5);	//	Add button into Frame 
		

		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}

User-defined layout
-------------------------------
import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		setLayout(new BorderLayout());
		setLayout(new FlowLayout());
		setLayout(new GridLayout(3,2));

		setLayout(null);	//	User-defined layout

		JButton b1 = new JButton("Submit");
		JButton b2 = new JButton("Reset");
		JButton b3 = new JButton("OK");
		JButton b4 = new JButton("Register");
		JButton b5 = new JButton("Login");

		add (b1);	//	Add button into Frame 
		add (b2);	//	Add button into Frame 
		add (b3);	//	Add button into Frame 
		add (b4);	//	Add button into Frame 
		add (b5);	//	Add button into Frame 
		
		b1.setBounds(100, 50, 130, 30);	//	x-axis , y-axis , width , height 
		b2.setBounds(100, 100, 130, 30);
		b3.setBounds(250, 100, 130, 30);

		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}


Login Page 
---------------------------
import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setLayout(null);	//	User-defined layout
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JLabel l1 = new JLabel("Enter Username : ");
		JLabel l2 = new JLabel("Enter Password : ");
		
		JTextField tf1 = new JTextField();
		JPasswordField ps1 = new JPasswordField();
		
		JButton b1 = new JButton("Submit");
		JButton b2 = new JButton("Reset");
		
		add(l1);
		add(l2);
		add(b1);
		add(b2);
		add(tf1);
		add(ps1);
		
		l1.setBounds(50,50,110,30);
		l2.setBounds(50,100,100,30);
		
		tf1.setBounds(170,50,180,30);
		ps1.setBounds(170,100,180,30);
		
		b1.setBounds(170,150,80,30);
		b2.setBounds(270,150,80,30);
		
		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}

JpasswordField
--------------------
	It provides a password field to user.
	It echos dot character . 

JTextField 
----------------------
	It provides a text field to user.
	ONly single line input is accepted. 

JCombobox 
--------------------
	It provides a dropdown box to user. 
	User can select only one element from dropdown box. 


import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setLayout(new FlowLayout());	//	User-defined layout
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		String c[] = {"Red","Green","Blue"};
		JComboBox cb1 = new JComboBox (c);
		add(cb1);
		
		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}



Checkbox 
--------------------
	It provides a multi selected option.

RadioButton 
-----------------------
	Here single selection only can be possible. 

import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setLayout(new FlowLayout());	//	User-defined layout
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		JCheckBox cb1 = new JCheckBox("Core Java",true);
		JCheckBox cb2 = new JCheckBox("Adv. Java");
		JCheckBox cb3 = new JCheckBox("UI");
		JCheckBox cb4 = new JCheckBox("Angular");
		
		add(cb1);
		add(cb2);
		add(cb3);
		add(cb4);
		
		JRadioButton rd1 = new JRadioButton("Male");
		JRadioButton rd2 = new JRadioButton("Female");
		ButtonGroup bg = new ButtonGroup();
		bg.add(rd1);
		bg.add(rd2);
		add(rd1);
		add(rd2);
		
		
		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}


TextArea using awt 
-----------------
	It provides multiline input field 

import java.awt.*;
import javax.swing.*;

public class Test extends JFrame {
	
	Test() {
		
		setLayout(new FlowLayout());
		
		TextArea ta1  = new TextArea();
		TextArea ta2 = new TextArea();
		add(ta1);
		add(ta2);
		
		setVisible(true);
		setSize(400, 400);
	} 
	public static void main(String[] args) {
		
		new Test();
	
	}
}


Event Handling 
=========================
	Something happening with the UI component is known as event such as  click on button / edit the text field / drag the Scrollbar etc. 

	For each and every event , one or more than one Listeners are available. 

	Listener 	:	Each & every listener in java is a pre-defined interface present in java.awt.event pacakge and responsible to handle the event. 
	Event 		:	Each & every event in java is a pre-defined class present in java.awt.event pacakge.

	Example of event and Listener 
	-------------------------------
	Event 						Listener
	---------------------		----------------
		ActionEvent 			ActionListener 
		MouseEvent				MouseListener 
								MouseMotionListener 
		WindowEvent 			WindowListener 
		ItemEvent 				ItemListener 
		TextEvent 				TextListener 
		AdjustmentEvent 		AdjustmentListener 
		.................		.....................
		..................		......................


Ways to handle the event 
------------------------------------
	1.	within the same class 
	2.	in a different class 
	3.	using anonymous class 

Steps 
---------------
	1.	Implements the required listener interface 
	2.	Override all the abstract method of that listner and put event handling code 
	3.	Register the component with event. 





ActionEvent and ActionListener
------------------------------------
	This event is generated when click on button or click on menu etc.
	ActionEvent is handled by ActionListener with the help of actionPerformed() method. 


How to Handle event within a same class 
--------------------------------------------
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class Test extends JFrame implements ActionListener 
{
	JButton b1,b2,b3,b4,b5;
	Test()
	{
		setLayout(null);// User-defined layout
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // close the JFrame
		b1 = new JButton("Login");
		b2 = new JButton("Reset");
		b3 = new JButton("Cancel");
		b4 = new JButton("Submit");
		b5 = new JButton("Save");
		
		add(b1);
		add(b2);
		add(b3);
		add(b4);
		add(b5);
		
		b1.setBounds(100, 50, 120, 30);
		b2.setBounds(100, 90, 120, 30);
		b3.setBounds(100, 130, 120, 30);
		b4.setBounds(100, 170, 120, 30);
		b5.setBounds(100, 210, 120, 30);
		
		
		setVisible(true);
		setSize(400, 300);

		// Register Event with Button 
		b1.addActionListener(this); // this means current class object , it means event handling code present in same class 
		b2.addActionListener(this);
		b3.addActionListener(this);
		b4.addActionListener(this);
		b5.addActionListener(this);

	}
	public void actionPerformed(ActionEvent ae)
	{
		if(ae.getSource() == b1)	//	It means if click on b1 
			System.out.println("Clicked on b1");
		if(ae.getSource() == b2)
			System.out.println("Clicked on b2");
		if(ae.getSource() == b3)
			System.out.println("Clicked on b3");
		if(ae.getSource() == b4)
			System.out.println("Clicked on b4");
		if(ae.getSource() == b5)
			System.out.println("Clicked on b5");

	}
	public static void main(String[] args) 
	{
		new Test();
	}
}


Example: How to handle the event in a different class 
----------------------------------------------------------
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class Test extends JFrame 
{
	static JButton b1,b2,b3,b4,b5;
	Test()
	{
		setLayout(null);// User-defined layout
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // close the JFrame
		b1 = new JButton("Login");
		b2 = new JButton("Reset");
		b3 = new JButton("Cancel");
		b4 = new JButton("Submit");
		b5 = new JButton("Save");
		
		add(b1);
		add(b2);
		add(b3);
		add(b4);
		add(b5);
		
		b1.setBounds(100, 50, 120, 30);
		b2.setBounds(100, 90, 120, 30);
		b3.setBounds(100, 130, 120, 30);
		b4.setBounds(100, 170, 120, 30);
		b5.setBounds(100, 210, 120, 30);
		
		
		setVisible(true);
		setSize(400, 300);

		// Register Event with Button 
		b1.addActionListener(new Demo()); // new Demo() means  event handling code present in Demo class 
		b2.addActionListener(new Demo());
		b3.addActionListener(new Demo());
		b4.addActionListener(new Demo());
		b5.addActionListener(new Demo());

	}
	public static void main(String[] args) 
	{
		new Test();
	}
}
class Demo implements ActionListener {


	public void actionPerformed(ActionEvent ae)
	{
		if(ae.getSource() == Test.b1)	//	It means if click on b1 
			System.out.println("Clicked on b1");
		if(ae.getSource() == Test.b2)
			System.out.println("Clicked on b2");
		if(ae.getSource() == Test.b3)
			System.out.println("Clicked on b3");
		if(ae.getSource() == Test.b4)
			System.out.println("Clicked on b4");
		if(ae.getSource() == Test.b5)
			System.out.println("Clicked on b5");

	}
}

Example: How to handle event using anonymous class 
--------------------------------------------------------
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class Test extends JFrame
{
	JButton b1,b2,b3,b4,b5;
	Test()
	{
		setLayout(null);// User-defined layout
		
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // close the JFrame
		b1 = new JButton("Login");
		b2 = new JButton("Reset");
		b3 = new JButton("Cancel");
		b4 = new JButton("Submit");
		b5 = new JButton("Save");
		
		add(b1);
		add(b2);
		add(b3);
		add(b4);
		add(b5);
		
		b1.setBounds(100, 50, 120, 30);
		b2.setBounds(100, 90, 120, 30);
		b3.setBounds(100, 130, 120, 30);
		b4.setBounds(100, 170, 120, 30);
		b5.setBounds(100, 210, 120, 30);
		
		
		setVisible(true);
		setSize(400, 300);

		// Register Event with Button 
		b1.addActionListener
		(
			new ActionListener() {
				
				public void actionPerformed(ActionEvent ae) {

					System.out.println("Hello");
				}
			}
		);

	}
	public static void main(String[] args) 
	{
		new Test();
	}
}



Example: Notepad 

import java.awt.*;
import java.awt.event.*;
import java.util.Date;
import javax.swing.*;

public class Test extends JFrame implements ActionListener {
    
    JTextArea ta1;
    JScrollPane p1;
    
    Test() {
        
        setTitle("Notepad");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        ta1 = new JTextArea();
        p1 = new JScrollPane(ta1);
        add(p1);
        
        JMenuBar mbr = new JMenuBar();
        add(mbr,BorderLayout.NORTH);
        JMenu file = new JMenu("FILE");
        JMenu edit = new JMenu("EDIT");
        mbr.add(file);
        mbr.add(edit);
        
        JMenuItem copy = new JMenuItem("COPY");
        JMenuItem paste = new JMenuItem("PASTE");
        JMenuItem selectall = new JMenuItem("SELECT ALL");
        JMenuItem cut = new JMenuItem("CUT");
        JMenuItem today = new JMenuItem("TODAY");
        
        edit.add(copy);
        edit.add(paste);
        edit.add(selectall);
        edit.add(cut);
        edit.add(today);
        
        setVisible(true);
        setSize(400, 400);
        
        copy.addActionListener(this);
        cut.addActionListener(this);
        paste.addActionListener(this);
        selectall.addActionListener(this);
        today.addActionListener(this);
        
        
    } 
    public void actionPerformed(ActionEvent e) {

        String text = e.getActionCommand(); // return text of the menu/button
        if (text.equals("COPY"))
            ta1.copy();
        if (text.equals("PASTE"))
            ta1.paste();
        if (text.equals("SELECT ALL"))
            ta1.selectAll();
        if (text.equals("CUT"))
            ta1.cut();
        if (text.equals("TODAY"))
            ta1.setText(""+new Date());
        
    }
    public static void main(String[] args) {
        
        new Test();
    }
}


Applet in Java 
----------------------------------------------
    Applet is just like a Frame, & it is used to create UI. 
   
    It is a pre-defined class present in java.applet package. 
        java.applet.Applet 


    It is used to create an UI which can be executed in web-browser , Not Supported in HTML5.

    Applet is deprecated / out-dated from latest JDK.

    Life cycle of Applet 
    ---------------------------

        Following are the life cycle methods of applet 

            init()  :   To initialize the applet like constructor in other. 

            start() :   To active the applet application

            paint() :   To draw graphics within applet. 

            stop()  :   To pause the applet application.

            destroy()   :   To release applet consumed memory. 

        Note:   init() and destroy() only execute for a single time during the life cycle of applet. 

Note:   The User-defined applet class must be public & should be sub-class of Applet. 

import java.applet.Applet;
import java.awt.*;
public class Test extends Applet 
{
    public  void init()
    {
        System.out.println("Applet initialized ");
    }
    public  void start()
    {
        System.out.println("Applet started ");
    }
    public  void paint(Graphics g)
    {
        System.out.println("Applet is painted ");
    }
    public  void stop()
    {
        System.out.println("Applet stopped ");
    }
    public  void destroy()
    {
        System.out.println("Applet destroyed ");
    }
}
// <applet width="300" height="300" code="Test.class"></applet> 
:\5-6>javac  Test.java

D:\5-6>appletviewer Test.java
Applet initialized
Applet started
Applet is painted
Applet stopped
Applet started
Applet is painted
Applet stopped
Applet destroyed


Example: Graphics class 
------------------------------------------
import java.applet.Applet;
import java.awt.*;
public class Test extends Applet 
{
    public  void paint(Graphics g)
    {
        g.setColor(Color.red);
        g.drawLine(50,50,200,50);// x1 , y1 , x2 , y2
        g.drawRect (100,70,50,50); // x ,y , width , height
        g.fillRect (100,150,50,50);

        g.drawOval (350,50,50,50); // x ,y , width , height
        g.fillOval (350,150,50,50);

        g.drawRect (200,250,300,350);
        g.fillArc (200,250,300,350,400,60); g.setColor(Color.green);
        g.fillArc (200,250,300,350,460,60); g.setColor(Color.blue);
        g.fillArc (200,250,300,350,520,60); g.setColor(Color.orange);
        g.fillArc (200,250,300,350,580,60); g.setColor(Color.cyan);
        g.fillArc (200,250,300,350,640,60); g.setColor(Color.gray);
        g.fillArc (200,250,300,350,700,60);
    }
}
// <applet width="300" height="300" code="Test.class"></applet>






Multithreading 
---------------------------

	Thread is a pre-defined  class present in java.lang package.
	This class is responsible to create and manipulate the Thread in Java.

	Constructors of Thread 
	--------------------------	
	Thread is  a light weight process. 

	Process :	Running program of computer is known as process. 

	Heavy Weight :	Process is always heavy weight i.e. each & every process allocates memory in a different location. 

	Light Weight :	All the threads share a common process memory. 

	A process unit is known as Thread. 

	Part of the process is known as Thread. 

	A process is divided into multiple , here each part is known as thread. 

	To execute more than one task at a single time, we have to use multithreading. 

	Multithreading is suitable for game and networking application. 
	Multithreading makes execution very faster.

	Constructors of Thread class 
	-----------------------------------------------------------
		Thread()
		Thread(String Thread_name)
		Thread(Runnable object)
		Thread(Runnable object, String Thread_name)


Life cycle of Thread 
---------------------------------
	Each & every thread having a life cycle from new born to dead state. 


Methods of Thread class 
-------------------------------------
	
		->	static Thread currentThread() : Return the object of current running Thread .
			Note:	currentThread() is not responsible to create a new Thread , it only returns the object.

		->	String getName() : Return the name of thread which is running currently.
		
		->	void setName (String Thread_name) : Assign name to Thread.
 			Note:	By default, name of the thread is given by JVM like Thread-0 , Thread-1 , Thread-2 ...etc. 

		->	void start() : 	To active the Thread i.e. move the new born state to running state. 
							It divides the process into two part. 
							Responsible to call run() method .
		
		->	void run() :	This method present in Thread class with blank implementation.  	
							As a Java programmer, the logic of thread application should be placed within run() method.
							It automatically call by start() method. 

		->	static void sleep(long millisecond) : It blocks the Thread for a specific period of times.
											  	After time completion, it automatically re-active. 

		
		->	void suspend() : Block the thread until resume() called.
		
		->	void resume(): Re-active the  suspended Thread. 

		->	void wait() : Block the thread until notify() or notifyAll() called. 
		
		->	void notify() : Re-active the first waited Thread. 
		
		->	void notifyAll() : Re-active the all waited Thread. 

		->	void join() : Block the current thread for running of another thread. 

		->	boolean isAlive() : Check the thread existence i.e. live or dead. 
		
		->	void stop() :  Forcefully move the thread to dead state. 


How to create an user-defined Thread in Java 
--------------------------------------------------------
	
	Thread can be constructed by two ways in Java 
		
		1.	By extends Thread class 

		2.	By implements Runnable interface

	Note:	It is better to create a Thread by implements Runnable interface as classes in Java doesnot support multiple inheritance. 

	Steps to create a Thread by extends Thread class
	---------------------------------------------------
		1.	Design an user-defined class and make this class as the sub-class of Thread.

		2.	Create the object of user-defined class & that object can be treated as Thread class object, because the object of sub-class can be treated as  the object of parent class. 

		3.	Call the start() method to active the thread. 

		4.	Override the run() method of Thread class , in which logic of the Thread will be designed. 


Note:	In Java, main thread is the first executable Thread i.e. default thread in java is main. 

			Each & every program in java contains a Thread i.e. main. 


class Demo {

	public static void main(String[] args) {
		
		System.out.println("Ok");
		System.out.println(Thread.currentThread().getName());
		System.out.println("Hi");
	}
}


`

Example:	How to create by extends Thread class   & Multiple thread with single job 
---------------------------------------------------------

class Demo extends Thread {  // 1 

	public void run () { // 4 
		System.out.println("User-defined Thread : "+Thread.currentThread().getName());
	}
	public static void main(String[] args) {
		
		System.out.println("Default Thread : "+Thread.currentThread().getName());

		Demo d1 = new Demo();  // 2 
		d1.start(); // 3

		System.out.println("Hello");

		Demo d2 = new Demo();
		d2.start();

		System.out.println("Hi");

		Demo d3 = new Demo();
		d3.start();

		System.out.println("Bye");

		Demo d4 = new Demo();
		d4.start();

		System.out.println("Ok");
	}
}



Steps to create a Thread by implements Runnable interface
---------------------------------------------------

		1.	Design an user-defined class and implements Runnable interface

		2.	Create the object of user-defined class & that object can be treated as Runnable interface object. 
		3.	Create the object of Thread class and pass Runnable object as an argument within the constructor of Thread.
		4.	Call the start() method to active the thread. 
		5.	Override the run() method which contains the logic of Thread. 


Example:	Creating thread by implements Runnable interface  & Multiple thread with multiple job 

class Test implements Runnable { // 1

	public void run() { // 5 
		System.out.println("Prime() Logic : "+ Thread.currentThread().getName());
	}
	public static void main(String[] args) {
		
		System.out.println("Hi : "+ Thread.currentThread().getName());
 
		Test t1 = new Test (); // 2 
		Thread th1 = new Thread (t1); // 3
		th1 . start (); // 4 

		Demo d1 = new Demo ();
		Thread th2 = new Thread (d1);
		th2 . start ();

		X x1 = new X ();
		Thread th3 = new Thread (x1);
		th3 . start ();

		System.out.println("Ok");
	}
}
class Demo implements Runnable {

	public void run() {
		System.out.println("Fact() Logic by : "+ Thread.currentThread().getName());
	}
}

class X implements Runnable {

	public void run() {
		System.out.println("sort() Logic by : "+ Thread.currentThread().getName());
	}
}



Method Implementation 
-----------------------------------------------
class Test implements Runnable {

	public void run() {

		for(int i=1 ; i <= 15 ; i++) {
		
			System.out.println(Thread.currentThread().getName());
			try {

				Thread.sleep(1000);
			}
			catch(Exception e) {

			}
		}
	}
	public static void main(String[] args) throws Exception {
		
		Test t1 = new Test ();
		Thread th1 = new Thread (t1);
		th1.setName("Java");
		th1 . start ();

		for(int i=1 ; i <= 5 ; i++) {
		
			System.out.println(Thread.currentThread().getName());
			Thread.sleep(1000);
		}
		System.out.println("Thread Java is suspended ..:) ");
		th1.suspend();
		Thread.sleep(4000);
		th1.resume();
		System.out.println("Thread Java is resumed ...:) ");

		if(th1.isAlive()) {

			System.out.println("Thread main is waiting for Java Thread ");
			th1.join(); // Block the current thread for running of another thread 
			System.out.println("Thread Java task is finished ");
		}
		System.out.println("Thread main exited ..:) ");
		System.exit(0);	//	Terminate the process 
	}
}



Thread synchronization 
===================================================

	synchronized is a keyword in Java , which is used to declare a method as synchronized method. 

	If the method is synchronized , it cannot be accessed by multiple Thread at a single time. 

	synchronized method support the concept of locking. 


class Table {

	synchronized public void printTable (int num) {

		for(int i =1 ; i <= 5 ; i++) {

			System.out.println(num * i );
			try {

				Thread.sleep(1000);
			}
			catch(Exception e) {

			}
		}
	}
}
class User1 implements Runnable {

	Table t1;
	User1(Table t) {

		t1 = t ; 

		Thread th1 = new Thread(this);
		th1.start();
	}
	public void run() {

		t1.printTable(5);
	}
}

class User2 implements Runnable {

	Table t1;
	User2(Table t) {

		t1 = t ; 

		Thread th1 = new Thread(this);
		th1.start();
	}
	public void run() {

		t1.printTable(6);
	}
}

class User3 implements Runnable {

	Table t1;
	User3(Table t) {

		t1 = t ; 

		Thread th1 = new Thread(this);
		th1.start();
	}
	public void run() {

		t1.printTable(7);
	}
}

class Test {

	public static void main(String[] args) {
		
		Table t = new Table ();
		new User1(t);
		new User2(t);
		new User3(t);
	}
}



Thread Priority 
---------------------------
	Each & every thread having a Priority in java . 
	By default, thread priority is 5. 

	To assign the priority we have to call setPriority() method.
	To know the priority we have to call getPriority() method. 

	Java provides three constant 

		MAX_PRIORITY	:	It shows the maximum priority of thread i.e. 10 
		MIN_PRIORITY	:	It shows the minimum priority of thread i.e. 1
		NORM_PRIORITY	:	It shows the Normal priority of thread i.e. 5 

	Note:	Range of the thread priority is 1-10. 





class Test implements Runnable {

	public void run()  {

	}

	public static void main(String[] args) {
		
		Test t = new Test();
		Thread th1 = new Thread(t);
		th1 . start();

		th1.setPriority(9);
		System.out.println(th1.getPriority() );
		System.out.println(Thread.MAX_PRIORITY);
		System.out.println(Thread.MIN_PRIORITY);
		System.out.println(Thread.NORM_PRIORITY);

	}
}




Networking in Java /  java.net package 
-----------------------------------------------------
    Process to Process communication is known as Networking.

    Process :   Running program of the computer is known as process. 

    If two different processes are running in a single system , then it is known as IPC (Inter Process Communication).

    If two different processes are running in two different system , then it is known as RPC (Remote Process Communication / Remote Procedural Call).


    Following are six components are required for Networking application

        1.  Server Process 
        2.  Client Process 
        3.  Ipaddress 
        4.  Portno 
        5.  Medium 
        6.  Protocol 

        1.  Server Process 
            --------------------------
            The process which is responsible to take request from one or more clients and provide response then that process is Server Process. 

        2.  Client Process 
            --------------------------
            The process which is responsible to give request to server and get response i.e. known client process. 


        3.  Ipaddress     
            -----------------------
                It is an unique identification number assigned to each system over a network to identify the system uniquly.

                Ipaddress is used to communicate between two system.

                If two processes are running in local system then we can use localhost/127.0.0.1/ip_address_local_system.

                If two processes are running in different system then we can use ip_address only. 



        4.  Portno 
            -----------------
                It is an unique identification number assigned to each process to identify the process uniquly. 

                Portno is used to communicate between two processes.

                Range of portno should be 0-65535

                Out 65536 ports , 0-1023 ports already reserved. 


        5.  Medium
            ------------
                A communication channel refers either to a physical transmission medium such as wire or to a logical communication such as wireless.


        6.  Protocol
            ----------------------
                It is a set of rules and regulations generally follows at the time of data transmission.

        
        Note:   All the classes & interfaces related  to networking paresent in java.net package.






Networking in Java /  java.net package 
-----------------------------------------------------
    Process to Process communication is known as Networking.

    Process :   Running program of the computer is known as process. 

    If two different processes are running in a single system , then it is known as IPC (Inter Process Communication).

    If two different processes are running in two different system , then it is known as RPC (Remote Process Communication / Remote Procedural Call).


    Following are six components are required for Networking application

        1.  Server Process 
        2.  Client Process 
        3.  Ipaddress 
        4.  Portno 
        5.  Medium 
        6.  Protocol 

        1.  Server Process 
            --------------------------
            The process which is responsible to take request from one or more clients and provide response then that process is Server Process. 

        2.  Client Process 
            --------------------------
            The process which is responsible to give request to server and get response i.e. known client process. 


        3.  Ipaddress     
            -----------------------
                It is an unique identification number assigned to each system over a network to identify the system uniquly.

                Ipaddress is used to communicate between two system.

                If two processes are running in local system then we can use localhost/127.0.0.1/ip_address_local_system.

                If two processes are running in different system then we can use ip_address only. 



        4.  Portno 
            -----------------
                It is an unique identification number assigned to each process to identify the process uniquly. 

                Portno is used to communicate between two processes.

                Range of portno should be 0-65535

                Out 65536 ports , 0-1023 ports already reserved. 


        5.  Medium
            ------------
                A communication channel refers either to a physical transmission medium such as wire or to a logical communication such as wireless.


        6.  Protocol
            ----------------------
                It is a set of rules and regulations generally follows at the time of data transmission.

        
        Note:   All the classes & interfaces related  to networking paresent in java.net package. 



  Example:    To get IPADDRESS of any system (local or remote)
        ---------------------------------------------------------------
import java.net.*;
class Test {

    public static void main(String[] args) throws Exception {
        
        InetAddress ip = InetAddress.getByName ("loalhost");
        System.out.println(ip);

        System.out.println(InetAddress.getByName("www.google.co.in"));
        //System.out.println(InetAddress.getByName("xyz"));//.UnknownHostException: No such host is known (xyz

    }
}

ipconfig :	to check ipadress in console 





java.net package provides two different class to communicate between two different process i.e. server and client process. 

    1.  Socket 
    2.  ServerSocket 

Socket 
---------------------
    It is a pre-defined class present in java.net package & responsible to established the connection from client end. 


    How to create object  of Socket class 
    -------------------------------------------
        Socket s1 = new socket (Ip_Address_server , Portno_server);


ServerSocket 
---------------------
    It is a pre-defined class present in java.net package & responsible to established the connection from server end. 


    How to create object  of ServerSocket class 
    -------------------------------------------
        ServerSocket ss = new Serversocket (Portno);

    Note:   Here portno is declared by Server & that portno will be used  by all clients. 

    accept()    :   It is used to block the server for client request. This method present in ServerSocket class. 



    Note :  localhost : If the process is running in current/local/same system then we can write localhost. 


Example3:   To communicate with server and client process in local/remote machine 
--------------------------------------------------------------------------------------
     
Server.java 
---------------  
import java.net.*;
class Server {

	public static void main(String[] args) throws Exception {
		
		ServerSocket ss = new ServerSocket (4567);

		System.out.println("Server is waiting for client ...:) ");
		ss.accept();
		System.out.print("Connected ....:) ");
	}
}

Client.java 
-------------------------
import java.net.*;
class Client {

	public static void main(String[] args) throws Exception {
		
		Socket s1 = new Socket (InetAddress.getByName("localhost"),4567);
	}
}

Note:	Run in two console 




























Example:   To communicate with server and client process in local/remote machine  and share message
-------------------------------------------------------------------------------------------------------
    
    Buffer :    It is a very special memory generally used by server and client process,  to do read and write operation. 

            Here server write data , client will read and client write data server will read. 


    java.net package provides two different class to do read and write operation in  buffer memory.

        1.  PrintWriter     -   It is used to write data into buffer with the help println() method.
                                
                   PrintWriter pw = new PrintWriter (socket_object.getOutputStream(),true);
                   pw.println (String message);


        2.  BufferedReader  -   It is used to read data from buffer with the of readLine() method. 

                    BufferedReader br = new BufferedReader(new InputStreamReader (socket_object.getInputStream()));





Example:   To communicate with server and client process in local/remote machine  and share message
-------------------------------

Server.java 
----------------------
import java.net.*;
import java.io.*;
class Server {

	public static void main(String[] args) throws Exception {
		
		ServerSocket ss = new ServerSocket (4567);

		System.out.println("Server is waiting for client ...:) ");
		Socket s1 = ss.accept();
		System.out.println("Connected ....:) ");

		BufferedReader br = new BufferedReader(new InputStreamReader (s1.getInputStream()));
		System.out.println("Message from client : "+br.readLine());

		br.close();
		s1.close();

	}
}

Client.java 
----------------------------------------------
import java.net.*;
import java.io.*;

class Client {

	public static void main(String[] args) throws Exception {
		
		Socket s1 = new Socket (InetAddress.getByName("localhost"),4567);

		PrintWriter pw = new PrintWriter (s1.getOutputStream(),true);
		pw.println ("Hello Welcome to distributed application ...:) ");

		pw.close();
		s1.close();

	}
}



Chatting Application 
------------------------------
import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.net.*;
import java.lang.*;

class ChatServer extends JFrame implements ActionListener , Runnable{

    JTextField tf1;
    JTextArea ta1;
    JScrollPane p1 ; 
    JButton b1; 

    ServerSocket ss ; 
    Socket s1;
    BufferedReader br ; 
    PrintWriter pw ;

    ChatServer() {

        /* User Interface starts here */
        setLayout(null);
        getContentPane() . setBackground(Color.cyan);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setTitle("Server");
        setLocation(200,200);
        setResizable(false);

        tf1 =  new JTextField ();
        ta1 = new JTextArea  ();
        p1 =  new JScrollPane (ta1);
        b1 =  new JButton ("Send");

        add (b1);
        add (p1);
        add (tf1);

        tf1.setBounds (30,30,150,30);
        b1.setBounds  (190,30,80,30);
        p1.setBounds  (30,70,240,250);
        
        setSize(320,400);
        setVisible(true);


        /* User Interface ends here */

        /*Networkign Code starts here */

        try {
            ss = new ServerSocket(5000);
            s1 = ss.accept();
            br = new BufferedReader(new InputStreamReader(s1.getInputStream()));
            pw = new PrintWriter (s1.getOutputStream() , true);
        }
        catch(Exception e) {
            
        }

        /*Networkign Code ends here */  


        /Event registration/
        b1.addActionListener(this);
        tf1.addActionListener(this);

        /Thread Object creation/
        Thread th1 = new Thread(this);
        th1.start();

    }

    /* Thead Logic , To read data from Buffer starts here */

    public void run() {

        while(true) {

            try {
                String text = br.readLine();
                ta1.append (text +" - Sender "+new Date()+"\n");    //  write data into own text area 
            }
            catch(Exception e) {

            }
        }
    }

    /* Thead Logic , To read data from Buffer ends here */


    /Event Handling code starts here/

    public void actionPerformed(ActionEvent ae) {

        String text = tf1.getText();
        tf1.setText("");    //  make text field empty 
        pw.println (text);  //  write data into buffer 
        ta1.append (text +" - Me "+new Date()+"\n");    //  write data into own text area 

    }

    /Event Handling code ends here/

    public static void main(String[] args) {
        
        new ChatServer();
    }
}

----------------------------------------------

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import java.awt.event.*;
import java.net.*;
import java.lang.*;

class ChatClient extends JFrame implements ActionListener , Runnable{

    JTextField tf1;
    JTextArea ta1;
    JScrollPane p1 ; 
    JButton b1; 

    ServerSocket ss ; 
    Socket s1;
    BufferedReader br ; 
    PrintWriter pw ;

    ChatClient() {

        /* User Interface starts here */
        setLayout(null);
        getContentPane() . setBackground(Color.orange);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setTitle("Client");
        setLocation(200,200);
        setResizable(false);

        tf1 =  new JTextField ();
        ta1 = new JTextArea  ();
        p1 =  new JScrollPane (ta1);
        b1 =  new JButton ("Send");

        add (b1);
        add (p1);
        add (tf1);

        tf1.setBounds (30,30,150,30);
        b1.setBounds  (190,30,80,30);
        p1.setBounds  (30,70,240,250);
        
        setSize(320,400);
        setVisible(true);


        /* User Interface ends here */

        /*Networkign Code starts here */

        try {
            //ss = new ServerSocket(5000);  // only for server 
            //s1 = ss.accept(); // only for server
            s1 = new Socket (InetAddress.getByName("localhost"),5000); // Only for client 

            br = new BufferedReader(new InputStreamReader(s1.getInputStream()));
            pw = new PrintWriter (s1.getOutputStream() , true);
        }
        catch(Exception e) {
            
        }

        /*Networkign Code ends here */  


        /Event registration/
        b1.addActionListener(this);
        tf1.addActionListener(this);

        /Thread Object creation/
        Thread th1 = new Thread(this);
        th1.start();

    }

    /* Thead Logic , To read data from Buffer starts here */

    public void run() {

        while(true) {

            try {
                String text = br.readLine();
                ta1.append (text +" - Sender "+new Date()+"\n");    //  write data into own text area 
            }
            catch(Exception e) {

            }
        }
    }

    /* Thead Logic , To read data from Buffer ends here */


    /Event Handling code starts here/

    public void actionPerformed(ActionEvent ae) {

        String text = tf1.getText();
        tf1.setText("");    //  make text field empty 
        pw.println (text);  //  write data into buffer 
        ta1.append (text +" - Me "+new Date() +"\n");   //  write data into own text area 

    }

    /Event Handling code ends here/

    public static void main(String[] args) {
        
        new ChatClient();
    }
}


JDBC (Java Database Connectivity)
------------------------------------------
    It is a technique which is used to communicate with Database server from Java application. 

    Java Application        ----JDBC---         Database-Server (Oracle/Mysql/Db2/...)
    ----------------        -------------       ---------------

    Database 
    --------------
        It is a container which store data permanently. 

        Permanently we can store data by file/database.

        To store/manipulate data in database server , we have to use SQL (Structured Query Language).

        In Database, data always stored in a tabular format.

        Table : Collection of records. 

        Record : Collection of inforamtion. 

        Information :   Processed data 

        SQL> conn system/system // Connect to Oracle Database server
		Connected.

        How to create table 
        -------------------------
            Create table Student (Roll  Number(4),  Name    char(20),Cgpa   Number(3,1) );

            Datatype 
            -------------
                Number  :   It store int value. 
                (4)     :   Maximum 4 digits are allowed. 

                char(20):   It store char/String values.
                            Maximum 20 characters are allowed. 

                Number(3,1):    It stores float and double values. 
                                3 means total 3 digits 
                                1 decimal point is allowed 

                                12.3

        How to insert record 
        ------------------------
            Insert  into student values (100,'Raja',7.8);
            Insert  into student values (101,'Rani',7.9);

        How to update the record 
        ----------------------------
            Update Student set name='Ajay' , cgpa=9.7 where roll=100;

        How to Delete the record 
        ---------------------------
            Delete from student where roll=101;
        
        How to select the record 
        --------------------------
            select roll,name,cgpa from student;

        How to drop the table 
        -------------------
            Drop table Student;





Steps to create a JDBC application
---------------------------------------------
	  1.  Load the Driver 
	  2.  Established the connection
	  3.  Create a request object 
	  4.  Execute the request
	  5.  Close the connection


    1.  Load the Driver 
    -------------------------
        How to load the driver

        	Class.forName ("oracle.jdbc.OracleDriver");

        OracleDriver    :   It is simply a class responsible to connect with Oracle database.
                            This class present in oracle.jdbc package. 
                            This package present on ojdbc14.jar file 
                            ojdbc14.jar file present in www.thetechpoint.in / Google

                            forName() : It is a static method present in java.lang.Class, & responsible to load the driver class into JVM. 

    2.  Established the connection
        
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system"); 

        getConnection() :   It is a static method present in DriverManager class.
        					It is responsible to Established the connection with DB server. 
                            After Established the connection , it returns the Connection object. 

                            jdbc:oracle:thin:       -       URL for ORACLE      
                            localhost:              -       DB running in local system 
                            1521:                   -       Portno of ORACLE 
                            xe                      -       Name of the Database
                            system                  -       Username of the Database
                            system                  -       Password of the Database

                        To develop this program , it is required to install ORACLE software. 


Example:    To Established the connection with ORACLE server from Java application
------------------------------------------------------------------------------------------------
import java.sql.*;
class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system"); 
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    

    }
}

Download ojdbc14.jar file & store into current folder. 

D:\6-8>set classpath=;ojdbc14.jar;

D:\6-8>javac Test.java

D:\6-8>java Test
Connected with ORACLE  ..:)



    3.  Create a request object 
        Statement st =con.createStatement();

        createStatement()   :    It is a method which return the object Statement interface.

    4.  Execute the request

    	To execute the request , following are two methods are available

        st.executeUpdate(); :   To execute any SQL query except SELECT statement.
        st.executeQuery();  :   To execute the SELECT statement only.


    5.  Close the connection
        con.close();

Note:   All the classes and interfaces related to JDBC present in java.sql package. 
        so required to import sql package in JDBC application. 




Example:    Connnect to DB server and drop the existing table 
---------------------------------------------------------------------

import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     //  1
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  //  2
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    //  3

        //Logic to drop the table 
        st.executeUpdate("Drop table Student"); //  4
        System.out.println("Table Dropped Successfully ...:) ");

        con.close();        //  5
    }
}



Example:    Connnect to DB server and create a new  table 
--------------------------------------------------------------------
import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    

        //Logic to Create the table 
        st.executeUpdate("Create table Student (Roll    Number(4),  Name    char(20),Cgpa   Number(3,1) )");    
        System.out.println("Table Created Successfully ...:) ");

        con.close();        
    }
}




Example:    Connnect to DB server and insert record
--------------------------------------------------------------------
import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    

        //Logic to drop Insert the record 
        st.executeUpdate("Insert  into student values (100,'Raja',7.8)");   
        System.out.println("Record Inserted Successfully ...:) ");

        st.executeUpdate("Insert  into student values (101,'Rani',7.9)");   
        System.out.println("Record Inserted Successfully ...:) ");

        con.close();        
    }
}


Example:    Connnect to DB server and Modify record
--------------------------------------------------------------------
import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    

        //Logic to update the record 
        st.executeUpdate("Update Student set name='Ajay' , cgpa=9.7 where roll=100");   
        System.out.println("Record Updated Successfully ...:) ");

        con.close();        
    }
}


Example:    Connnect to DB server and delete record
--------------------------------------------------------------------
import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    

        //Logic to Delete the record 
        st.executeUpdate("Delete from student where roll=100"); 
        System.out.println("Record Deleted Successfully ...:) ");

        con.close();        
    }
}


Example:    Connnect to DB server and select  record
--------------------------------------------------------------------

import java.sql.*;

class Test {

    public static void main(String[] args) throws Exception {
        

        Class.forName ("oracle.jdbc.OracleDriver");     
        Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");  
        if(con != null)
            System.out.println("Connected with ORACLE  ..:) ");
    
        Statement st =con.createStatement();    

        //Logic to Select Insert the record 
        ResultSet rs = st.executeQuery("select roll,name,cgpa from student"); // After executeQuery() execute the select statement,  return a virtual table , & that virtual table can be stored in ResultSet object, now it is require to traverse the ResultSet. 

        while(rs.next()) {  //  next() method check the next record existence.

            System.out.println(rs.getInt(1) +"\t"+ rs.getString(2) +"\t"+ rs.getDouble(3) );
        }

        // Here 1 , 2 and 3 represent column number 
        // getInt() :   represent for roll number 
        //  getString() :Fetch data from name column i.e. String 
        //  getDouble : Fetch data from cgpa column i.e. double type 
        
        System.out.println("Record Selected Successfully ...:) ");

        con.close();        
    }
}

